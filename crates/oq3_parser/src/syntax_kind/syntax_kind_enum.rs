//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(bad_style, missing_docs, unreachable_pub)]
#[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    #[doc = r" punctuation"]
    BANG,
    NEQ,
    POUND,
    DOLLAR,
    PERCENT,
    PERCENTEQ,
    AMP,
    AMP2,
    AMPEQ,
    L_PAREN,
    R_PAREN,
    STAR,
    DOUBLE_STAR,
    STAREQ,
    PLUS,
    DOUBLE_PLUS,
    PLUSEQ,
    COMMA,
    MINUS,
    MINUSEQ,
    THIN_ARROW,
    DOT,
    DOT2,
    DOT3,
    DOT2EQ,
    SLASH,
    SLASHEQ,
    COLON,
    COLON2,
    SEMICOLON,
    L_ANGLE,
    SHL,
    SHLEQ,
    LTEQ,
    EQ,
    EQ2,
    FAT_ARROW,
    R_ANGLE,
    GTEQ,
    SHR,
    SHREQ,
    QUESTION,
    AT,
    L_BRACK,
    R_BRACK,
    CARET,
    CARETEQ,
    UNDERSCORE,
    L_CURLY,
    PIPE,
    PIPEEQ,
    PIPE2,
    R_CURLY,
    TILDE,
    #[doc = r" all_keywords"]
    O_P_E_N_Q_A_S_M_KW,
    BARRIER_KW,
    BOX_KW,
    CAL_KW,
    CONST_KW,
    DEF_KW,
    DEFCAL_KW,
    DEFCALGRAMMAR_KW,
    DELAY_KW,
    EXTERN_KW,
    GATE_KW,
    GPHASE_KW,
    INCLUDE_KW,
    LET_KW,
    MEASURE_KW,
    PRAGMA_KW,
    DIM_KW,
    RESET_KW,
    BREAK_KW,
    CASE_KW,
    CONTINUE_KW,
    DEFAULT_KW,
    ELSE_KW,
    END_KW,
    FOR_KW,
    IF_KW,
    IN_KW,
    RETURN_KW,
    SWITCH_KW,
    WHILE_KW,
    ARRAY_KW,
    CREG_KW,
    INPUT_KW,
    MUTABLE_KW,
    OUTPUT_KW,
    QREG_KW,
    QUBIT_KW,
    READONLY_KW,
    VOID_KW,
    CTRL_KW,
    INV_KW,
    NEGCTRL_KW,
    POW_KW,
    FALSE_KW,
    TRUE_KW,
    #[doc = r" literals"]
    BIT_STRING,
    BYTE,
    CHAR,
    FLOAT_NUMBER,
    INT_NUMBER,
    STRING,
    #[doc = r" scalar_types"]
    ANGLE_TY,
    BIT_TY,
    BOOL_TY,
    COMPLEX_TY,
    DURATION_TY,
    FLOAT_TY,
    INT_TY,
    STRETCH_TY,
    UINT_TY,
    #[doc = r" tokens"]
    ANNOTATION,
    COMMENT,
    ERROR,
    HARDWAREIDENT,
    IDENT,
    PRAGMA,
    WHITESPACE,
    #[doc = r" nodes"]
    ANNOTATION_STATEMENT,
    BARRIER,
    CAL,
    CONST,
    DEF,
    DEF_CAL,
    DEF_CAL_GRAMMAR,
    DELAY_STMT,
    EXTERN_STMT,
    GATE,
    MEASURE,
    PRAGMA_STATEMENT,
    RESET,
    SOURCE_FILE,
    TIMING_LITERAL,
    DIM_EXPR,
    ARRAY_EXPR,
    BLOCK_EXPR,
    BOX_EXPR,
    BREAK_STMT,
    CASE_EXPR,
    CONTINUE_STMT,
    END_STMT,
    FOR_ITERABLE,
    FOR_STMT,
    IF_STMT,
    LET_STMT,
    PAREN_EXPR,
    RETURN_EXPR,
    STMT_LIST,
    SWITCH_CASE_STMT,
    TUPLE_EXPR,
    WHILE_STMT,
    CALL_EXPR,
    CAST_EXPRESSION,
    GATE_CALL_EXPR,
    G_PHASE_CALL_EXPR,
    INDEX_EXPR,
    MODIFIED_GATE_CALL_EXPR,
    ARG_LIST,
    BIN_EXPR,
    DECLARATION,
    EXPR_STMT,
    FILE_PATH,
    INCLUDE,
    LITERAL,
    NAME,
    PARAM,
    PARAM_LIST,
    PREFIX_EXPR,
    QUBIT_LIST,
    RANGE_EXPR,
    TYPE,
    TYPED_PARAM,
    TYPED_PARAM_LIST,
    TYPE_LIST,
    VERSION,
    VERSION_STRING,
    ALIAS_DECLARATION_STATEMENT,
    ARRAY_LITERAL,
    ARRAY_TYPE,
    ASSIGNMENT_STMT,
    CLASSICAL_DECLARATION_STATEMENT,
    DESIGNATOR,
    EXPRESSION_LIST,
    GATE_OPERAND,
    HARDWARE_QUBIT,
    IDENTIFIER,
    INDEXED_IDENTIFIER,
    INDEX_KIND,
    INDEX_OPERATOR,
    I_O_DECLARATION_STATEMENT,
    MEASURE_EXPRESSION,
    OLD_STYLE_DECLARATION_STATEMENT,
    QUANTUM_DECLARATION_STATEMENT,
    QUBIT_TYPE,
    RETURN_SIGNATURE,
    SCALAR_TYPE,
    SET_EXPRESSION,
    CTRL_MODIFIER,
    INV_MODIFIER,
    MODIFIER,
    NEG_CTRL_MODIFIER,
    POW_MODIFIER,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    pub fn is_keyword(self) -> bool {
        matches!(
            self,
            O_P_E_N_Q_A_S_M_KW
                | BARRIER_KW
                | BOX_KW
                | CAL_KW
                | CONST_KW
                | DEF_KW
                | DEFCAL_KW
                | DEFCALGRAMMAR_KW
                | DELAY_KW
                | EXTERN_KW
                | GATE_KW
                | GPHASE_KW
                | INCLUDE_KW
                | LET_KW
                | MEASURE_KW
                | PRAGMA_KW
                | DIM_KW
                | RESET_KW
                | BREAK_KW
                | CASE_KW
                | CONTINUE_KW
                | DEFAULT_KW
                | ELSE_KW
                | END_KW
                | FOR_KW
                | IF_KW
                | IN_KW
                | RETURN_KW
                | SWITCH_KW
                | WHILE_KW
                | ARRAY_KW
                | CREG_KW
                | INPUT_KW
                | MUTABLE_KW
                | OUTPUT_KW
                | QREG_KW
                | QUBIT_KW
                | READONLY_KW
                | VOID_KW
                | CTRL_KW
                | INV_KW
                | NEGCTRL_KW
                | POW_KW
                | FALSE_KW
                | TRUE_KW
        )
    }
    pub fn is_punct(self) -> bool {
        matches!(
            self,
            BANG | NEQ
                | POUND
                | DOLLAR
                | PERCENT
                | PERCENTEQ
                | AMP
                | AMP2
                | AMPEQ
                | L_PAREN
                | R_PAREN
                | STAR
                | DOUBLE_STAR
                | STAREQ
                | PLUS
                | DOUBLE_PLUS
                | PLUSEQ
                | COMMA
                | MINUS
                | MINUSEQ
                | THIN_ARROW
                | DOT
                | DOT2
                | DOT3
                | DOT2EQ
                | SLASH
                | SLASHEQ
                | COLON
                | COLON2
                | SEMICOLON
                | L_ANGLE
                | SHL
                | SHLEQ
                | LTEQ
                | EQ
                | EQ2
                | FAT_ARROW
                | R_ANGLE
                | GTEQ
                | SHR
                | SHREQ
                | QUESTION
                | AT
                | L_BRACK
                | R_BRACK
                | CARET
                | CARETEQ
                | UNDERSCORE
                | L_CURLY
                | PIPE
                | PIPEEQ
                | PIPE2
                | R_CURLY
                | TILDE
        )
    }
    pub fn is_literal(self) -> bool {
        matches!(
            self,
            BIT_STRING | BYTE | CHAR | FLOAT_NUMBER | INT_NUMBER | STRING
        )
    }
    pub fn is_scalar_type(self) -> bool {
        matches!(
            self,
            ANGLE_TY
                | BIT_TY
                | BOOL_TY
                | COMPLEX_TY
                | DURATION_TY
                | FLOAT_TY
                | INT_TY
                | STRETCH_TY
                | UINT_TY
        )
    }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "OPENQASM" => O_P_E_N_Q_A_S_M_KW,
            "barrier" => BARRIER_KW,
            "box" => BOX_KW,
            "cal" => CAL_KW,
            "const" => CONST_KW,
            "def" => DEF_KW,
            "defcal" => DEFCAL_KW,
            "defcalgrammar" => DEFCALGRAMMAR_KW,
            "delay" => DELAY_KW,
            "extern" => EXTERN_KW,
            "gate" => GATE_KW,
            "gphase" => GPHASE_KW,
            "include" => INCLUDE_KW,
            "let" => LET_KW,
            "measure" => MEASURE_KW,
            "pragma" => PRAGMA_KW,
            "dim" => DIM_KW,
            "reset" => RESET_KW,
            "break" => BREAK_KW,
            "case" => CASE_KW,
            "continue" => CONTINUE_KW,
            "default" => DEFAULT_KW,
            "else" => ELSE_KW,
            "end" => END_KW,
            "for" => FOR_KW,
            "if" => IF_KW,
            "in" => IN_KW,
            "return" => RETURN_KW,
            "switch" => SWITCH_KW,
            "while" => WHILE_KW,
            "array" => ARRAY_KW,
            "creg" => CREG_KW,
            "input" => INPUT_KW,
            "mutable" => MUTABLE_KW,
            "output" => OUTPUT_KW,
            "qreg" => QREG_KW,
            "qubit" => QUBIT_KW,
            "readonly" => READONLY_KW,
            "void" => VOID_KW,
            "ctrl" => CTRL_KW,
            "inv" => INV_KW,
            "negctrl" => NEGCTRL_KW,
            "pow" => POW_KW,
            "false" => FALSE_KW,
            "true" => TRUE_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_scalar_type(type_name: &str) -> Option<SyntaxKind> {
        let ty = match type_name {
            "angle" => ANGLE_TY,
            "bit" => BIT_TY,
            "bool" => BOOL_TY,
            "complex" => COMPLEX_TY,
            "duration" => DURATION_TY,
            "float" => FLOAT_TY,
            "int" => INT_TY,
            "stretch" => STRETCH_TY,
            "uint" => UINT_TY,
            _ => return None,
        };
        Some(ty)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            '!' => BANG,
            '#' => POUND,
            '$' => DOLLAR,
            '%' => PERCENT,
            '&' => AMP,
            '(' => L_PAREN,
            ')' => R_PAREN,
            '*' => STAR,
            '+' => PLUS,
            ',' => COMMA,
            '-' => MINUS,
            '.' => DOT,
            '/' => SLASH,
            ':' => COLON,
            ';' => SEMICOLON,
            '<' => L_ANGLE,
            '=' => EQ,
            '>' => R_ANGLE,
            '?' => QUESTION,
            '@' => AT,
            '[' => L_BRACK,
            ']' => R_BRACK,
            '^' => CARET,
            '_' => UNDERSCORE,
            '{' => L_CURLY,
            '|' => PIPE,
            '}' => R_CURLY,
            '~' => TILDE,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
macro_rules ! T { [!] => { $ crate :: SyntaxKind :: BANG } ; [!=] => { $ crate :: SyntaxKind :: NEQ } ; [#] => { $ crate :: SyntaxKind :: POUND } ; [$] => { $ crate :: SyntaxKind :: DOLLAR } ; [%] => { $ crate :: SyntaxKind :: PERCENT } ; [%=] => { $ crate :: SyntaxKind :: PERCENTEQ } ; [&] => { $ crate :: SyntaxKind :: AMP } ; [&&] => { $ crate :: SyntaxKind :: AMP2 } ; [&=] => { $ crate :: SyntaxKind :: AMPEQ } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [**] => { $ crate :: SyntaxKind :: DOUBLE_STAR } ; [*=] => { $ crate :: SyntaxKind :: STAREQ } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [++] => { $ crate :: SyntaxKind :: DOUBLE_PLUS } ; [+=] => { $ crate :: SyntaxKind :: PLUSEQ } ; [,] => { $ crate :: SyntaxKind :: COMMA } ; [-] => { $ crate :: SyntaxKind :: MINUS } ; [-=] => { $ crate :: SyntaxKind :: MINUSEQ } ; [->] => { $ crate :: SyntaxKind :: THIN_ARROW } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [..] => { $ crate :: SyntaxKind :: DOT2 } ; [...] => { $ crate :: SyntaxKind :: DOT3 } ; [..=] => { $ crate :: SyntaxKind :: DOT2EQ } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; [/=] => { $ crate :: SyntaxKind :: SLASHEQ } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [::] => { $ crate :: SyntaxKind :: COLON2 } ; [;] => { $ crate :: SyntaxKind :: SEMICOLON } ; [<] => { $ crate :: SyntaxKind :: L_ANGLE } ; [<<] => { $ crate :: SyntaxKind :: SHL } ; [<<=] => { $ crate :: SyntaxKind :: SHLEQ } ; [<=] => { $ crate :: SyntaxKind :: LTEQ } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [==] => { $ crate :: SyntaxKind :: EQ2 } ; [=>] => { $ crate :: SyntaxKind :: FAT_ARROW } ; [>] => { $ crate :: SyntaxKind :: R_ANGLE } ; [>=] => { $ crate :: SyntaxKind :: GTEQ } ; [>>] => { $ crate :: SyntaxKind :: SHR } ; [>>=] => { $ crate :: SyntaxKind :: SHREQ } ; [?] => { $ crate :: SyntaxKind :: QUESTION } ; [@] => { $ crate :: SyntaxKind :: AT } ; ['['] => { $ crate :: SyntaxKind :: L_BRACK } ; [']'] => { $ crate :: SyntaxKind :: R_BRACK } ; [^] => { $ crate :: SyntaxKind :: CARET } ; [^=] => { $ crate :: SyntaxKind :: CARETEQ } ; [_] => { $ crate :: SyntaxKind :: UNDERSCORE } ; ['{'] => { $ crate :: SyntaxKind :: L_CURLY } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [|=] => { $ crate :: SyntaxKind :: PIPEEQ } ; [||] => { $ crate :: SyntaxKind :: PIPE2 } ; ['}'] => { $ crate :: SyntaxKind :: R_CURLY } ; [~] => { $ crate :: SyntaxKind :: TILDE } ; [OPENQASM] => { $ crate :: SyntaxKind :: O_P_E_N_Q_A_S_M_KW } ; [barrier] => { $ crate :: SyntaxKind :: BARRIER_KW } ; [box] => { $ crate :: SyntaxKind :: BOX_KW } ; [cal] => { $ crate :: SyntaxKind :: CAL_KW } ; [const] => { $ crate :: SyntaxKind :: CONST_KW } ; [def] => { $ crate :: SyntaxKind :: DEF_KW } ; [defcal] => { $ crate :: SyntaxKind :: DEFCAL_KW } ; [defcalgrammar] => { $ crate :: SyntaxKind :: DEFCALGRAMMAR_KW } ; [delay] => { $ crate :: SyntaxKind :: DELAY_KW } ; [extern] => { $ crate :: SyntaxKind :: EXTERN_KW } ; [gate] => { $ crate :: SyntaxKind :: GATE_KW } ; [gphase] => { $ crate :: SyntaxKind :: GPHASE_KW } ; [include] => { $ crate :: SyntaxKind :: INCLUDE_KW } ; [let] => { $ crate :: SyntaxKind :: LET_KW } ; [measure] => { $ crate :: SyntaxKind :: MEASURE_KW } ; [pragma] => { $ crate :: SyntaxKind :: PRAGMA_KW } ; [dim] => { $ crate :: SyntaxKind :: DIM_KW } ; [reset] => { $ crate :: SyntaxKind :: RESET_KW } ; [break] => { $ crate :: SyntaxKind :: BREAK_KW } ; [case] => { $ crate :: SyntaxKind :: CASE_KW } ; [continue] => { $ crate :: SyntaxKind :: CONTINUE_KW } ; [default] => { $ crate :: SyntaxKind :: DEFAULT_KW } ; [else] => { $ crate :: SyntaxKind :: ELSE_KW } ; [end] => { $ crate :: SyntaxKind :: END_KW } ; [for] => { $ crate :: SyntaxKind :: FOR_KW } ; [if] => { $ crate :: SyntaxKind :: IF_KW } ; [in] => { $ crate :: SyntaxKind :: IN_KW } ; [return] => { $ crate :: SyntaxKind :: RETURN_KW } ; [switch] => { $ crate :: SyntaxKind :: SWITCH_KW } ; [while] => { $ crate :: SyntaxKind :: WHILE_KW } ; [array] => { $ crate :: SyntaxKind :: ARRAY_KW } ; [creg] => { $ crate :: SyntaxKind :: CREG_KW } ; [input] => { $ crate :: SyntaxKind :: INPUT_KW } ; [mutable] => { $ crate :: SyntaxKind :: MUTABLE_KW } ; [output] => { $ crate :: SyntaxKind :: OUTPUT_KW } ; [qreg] => { $ crate :: SyntaxKind :: QREG_KW } ; [qubit] => { $ crate :: SyntaxKind :: QUBIT_KW } ; [readonly] => { $ crate :: SyntaxKind :: READONLY_KW } ; [void] => { $ crate :: SyntaxKind :: VOID_KW } ; [ctrl] => { $ crate :: SyntaxKind :: CTRL_KW } ; [inv] => { $ crate :: SyntaxKind :: INV_KW } ; [negctrl] => { $ crate :: SyntaxKind :: NEGCTRL_KW } ; [pow] => { $ crate :: SyntaxKind :: POW_KW } ; [false] => { $ crate :: SyntaxKind :: FALSE_KW } ; [true] => { $ crate :: SyntaxKind :: TRUE_KW } ; [angle] => { $ crate :: SyntaxKind :: ANGLE_TY } ; [bit] => { $ crate :: SyntaxKind :: BIT_TY } ; [bool] => { $ crate :: SyntaxKind :: BOOL_TY } ; [complex] => { $ crate :: SyntaxKind :: COMPLEX_TY } ; [duration] => { $ crate :: SyntaxKind :: DURATION_TY } ; [float] => { $ crate :: SyntaxKind :: FLOAT_TY } ; [int] => { $ crate :: SyntaxKind :: INT_TY } ; [stretch] => { $ crate :: SyntaxKind :: STRETCH_TY } ; [uint] => { $ crate :: SyntaxKind :: UINT_TY } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; }
pub use T;
