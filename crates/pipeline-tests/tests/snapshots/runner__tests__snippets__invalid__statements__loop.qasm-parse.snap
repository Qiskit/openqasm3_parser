---
source: crates/pipeline-tests/tests/runner.rs
expression: parse_snap
---
id: tests/snippets/invalid/statements/loop.qasm
expect-parse: Diag
--- parser ---
ok: false
panicked: false
errors: 43
--- ast ---
SOURCE_FILE@0..346: 
for myvar in { 1, 2, 3 };
for myvar1, myvar2 in { 1, 2, 3 } { x $0; }
for myvar in { x $0; } { x $0; }
for myvar in for { x $0; }
for myvar { x $0; }
for (true) { x $0; }
for { x $0; }
for for in { 1, 2, 3 } { x $0; }
for in { 1, 2, 3 } { x $0; }
while true { x $0; }
while (true) (true) { x $0; }
while x in { 1, 2, 3 } { x $0; }
while (true);

FOR_STMT@1..26: for myvar in { 1, 2, 3 };
SCALAR_TYPE@5..5: 
NAME@5..10: myvar
FOR_ITERABLE@14..25: { 1, 2, 3 }
SET_EXPRESSION@14..25: { 1, 2, 3 }
EXPRESSION_LIST@16..23: 1, 2, 3
LITERAL@16..17: 1
LITERAL@19..20: 2
LITERAL@22..23: 3
FOR_STMT@27..45: for myvar1, myvar2
SCALAR_TYPE@31..31: 
NAME@31..37: myvar1
FOR_ITERABLE@37..38: ,
ERROR@37..38: ,
EXPR_STMT@39..45: myvar2
IDENTIFIER@39..45: myvar2
ERROR@46..48: in
EXPR_STMT@49..60: { 1, 2, 3 }
BLOCK_EXPR@49..60: { 1, 2, 3 }
EXPR_STMT@51..52: 1
LITERAL@51..52: 1
ERROR@52..53: ,
EXPR_STMT@54..55: 2
LITERAL@54..55: 2
ERROR@55..56: ,
LITERAL@57..58: 3
EXPR_STMT@61..70: { x $0; }
BLOCK_EXPR@61..70: { x $0; }
EXPR_STMT@63..68: x $0;
GATE_CALL_EXPR@63..67: x $0
IDENTIFIER@63..64: x
QUBIT_LIST@65..67: $0
HARDWARE_QUBIT@65..67: $0
FOR_STMT@71..91: for myvar in { x $0;
SCALAR_TYPE@75..75: 
NAME@75..80: myvar
FOR_ITERABLE@84..90: { x $0
SET_EXPRESSION@84..90: { x $0
EXPRESSION_LIST@86..90: x $0
GATE_CALL_EXPR@86..90: x $0
IDENTIFIER@86..87: x
QUBIT_LIST@88..90: $0
HARDWARE_QUBIT@88..90: $0
ERROR@92..93: }
EXPR_STMT@94..103: { x $0; }
BLOCK_EXPR@94..103: { x $0; }
EXPR_STMT@96..101: x $0;
GATE_CALL_EXPR@96..100: x $0
IDENTIFIER@96..97: x
QUBIT_LIST@98..100: $0
HARDWARE_QUBIT@98..100: $0
FOR_STMT@104..130: for myvar in for { x $0; }
SCALAR_TYPE@108..108: 
NAME@108..113: myvar
FOR_ITERABLE@117..120: for
ERROR@117..120: for
BLOCK_EXPR@121..130: { x $0; }
EXPR_STMT@123..128: x $0;
GATE_CALL_EXPR@123..127: x $0
IDENTIFIER@123..124: x
QUBIT_LIST@125..127: $0
HARDWARE_QUBIT@125..127: $0
FOR_STMT@131..148: for myvar { x $0;
SCALAR_TYPE@135..135: 
NAME@135..140: myvar
FOR_ITERABLE@141..147: { x $0
SET_EXPRESSION@141..147: { x $0
EXPRESSION_LIST@143..147: x $0
GATE_CALL_EXPR@143..147: x $0
IDENTIFIER@143..144: x
QUBIT_LIST@145..147: $0
HARDWARE_QUBIT@145..147: $0
ERROR@149..150: }
FOR_STMT@151..161: for (true)
SCALAR_TYPE@155..155: 
ERROR@155..156: (
FOR_ITERABLE@156..160: true
LITERAL@156..160: true
ERROR@160..161: )
EXPR_STMT@162..171: { x $0; }
BLOCK_EXPR@162..171: { x $0; }
EXPR_STMT@164..169: x $0;
GATE_CALL_EXPR@164..168: x $0
IDENTIFIER@164..165: x
QUBIT_LIST@166..168: $0
HARDWARE_QUBIT@166..168: $0
FOR_STMT@172..183: for { x $0;
SCALAR_TYPE@176..176: 
FOR_ITERABLE@176..182: { x $0
SET_EXPRESSION@176..182: { x $0
EXPRESSION_LIST@178..182: x $0
GATE_CALL_EXPR@178..182: x $0
IDENTIFIER@178..179: x
QUBIT_LIST@180..182: $0
HARDWARE_QUBIT@180..182: $0
ERROR@184..185: }
FOR_STMT@186..218: for for in { 1, 2, 3 } { x $0; }
SCALAR_TYPE@190..190: 
ERROR@190..193: for
FOR_ITERABLE@197..208: { 1, 2, 3 }
SET_EXPRESSION@197..208: { 1, 2, 3 }
EXPRESSION_LIST@199..206: 1, 2, 3
LITERAL@199..200: 1
LITERAL@202..203: 2
LITERAL@205..206: 3
BLOCK_EXPR@209..218: { x $0; }
EXPR_STMT@211..216: x $0;
GATE_CALL_EXPR@211..215: x $0
IDENTIFIER@211..212: x
QUBIT_LIST@213..215: $0
HARDWARE_QUBIT@213..215: $0
FOR_STMT@219..247: for in { 1, 2, 3 } { x $0; }
SCALAR_TYPE@223..223: 
ERROR@223..225: in
FOR_ITERABLE@226..237: { 1, 2, 3 }
SET_EXPRESSION@226..237: { 1, 2, 3 }
EXPRESSION_LIST@228..235: 1, 2, 3
LITERAL@228..229: 1
LITERAL@231..232: 2
LITERAL@234..235: 3
BLOCK_EXPR@238..247: { x $0; }
EXPR_STMT@240..245: x $0;
GATE_CALL_EXPR@240..244: x $0
IDENTIFIER@240..241: x
QUBIT_LIST@242..244: $0
HARDWARE_QUBIT@242..244: $0
WHILE_STMT@248..268: while true { x $0; }
LITERAL@254..258: true
BLOCK_EXPR@259..268: { x $0; }
EXPR_STMT@261..266: x $0;
GATE_CALL_EXPR@261..265: x $0
IDENTIFIER@261..262: x
QUBIT_LIST@263..265: $0
HARDWARE_QUBIT@263..265: $0
WHILE_STMT@269..288: while (true) (true)
LITERAL@276..280: true
EXPR_STMT@282..288: (true)
PAREN_EXPR@282..288: (true)
LITERAL@283..287: true
EXPR_STMT@289..298: { x $0; }
BLOCK_EXPR@289..298: { x $0; }
EXPR_STMT@291..296: x $0;
GATE_CALL_EXPR@291..295: x $0
IDENTIFIER@291..292: x
QUBIT_LIST@293..295: $0
HARDWARE_QUBIT@293..295: $0
WHILE_STMT@299..309: while x in
IDENTIFIER@305..306: x
ERROR@307..309: in
EXPR_STMT@310..321: { 1, 2, 3 }
BLOCK_EXPR@310..321: { 1, 2, 3 }
EXPR_STMT@312..313: 1
LITERAL@312..313: 1
ERROR@313..314: ,
EXPR_STMT@315..316: 2
LITERAL@315..316: 2
ERROR@316..317: ,
LITERAL@318..319: 3
EXPR_STMT@322..331: { x $0; }
BLOCK_EXPR@322..331: { x $0; }
EXPR_STMT@324..329: x $0;
GATE_CALL_EXPR@324..328: x $0
IDENTIFIER@324..325: x
QUBIT_LIST@326..328: $0
HARDWARE_QUBIT@326..328: $0
WHILE_STMT@332..345: while (true);
LITERAL@339..343: true
