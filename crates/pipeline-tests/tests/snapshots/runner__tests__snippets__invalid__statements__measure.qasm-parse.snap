---
source: crates/pipeline-tests/tests/runner.rs
expression: parse_snap
---
id: tests/snippets/invalid/statements/measure.qasm
expect-parse: Diag
--- parser ---
ok: false
panicked: false
errors: 15
--- ast ---
SOURCE_FILE@0..274: // lex: ok
// parse: diag
// sema: skip

measure $0, $1;
a[0:1] = measure $0, $1;
a = measure $0 -> b;
creg a[1] = measure $0;
measure $0 -> creg a[1];
measure $0 -> bit[1] a;
// Measure can't be used in sub-expressions.
a = 2 * measure $0;
a = (measure $0) + (measure $1);

EXPR_STMT@41..51: measure $0
MEASURE_EXPRESSION@41..51: measure $0
HARDWARE_QUBIT@49..51: $0
ERROR@51..52: ,
EXPR_STMT@53..56: $1;
HARDWARE_QUBIT@53..55: $1
ASSIGNMENT_STMT@57..76: a[0:1] = measure $0
INDEXED_IDENTIFIER@57..63: a[0:1]
IDENTIFIER@57..58: a
INDEX_OPERATOR@58..63: [0:1]
EXPRESSION_LIST@59..62: 0:1
RANGE_EXPR@59..62: 0:1
LITERAL@59..60: 0
LITERAL@61..62: 1
MEASURE_EXPRESSION@66..76: measure $0
HARDWARE_QUBIT@74..76: $0
ERROR@76..77: ,
EXPR_STMT@78..81: $1;
HARDWARE_QUBIT@78..80: $1
EXPR_STMT@82..99: a = measure $0 ->
BIN_EXPR@82..99: a = measure $0 ->
ASSIGNMENT_STMT@82..96: a = measure $0
IDENTIFIER@82..83: a
MEASURE_EXPRESSION@86..96: measure $0
HARDWARE_QUBIT@94..96: $0
ERROR@98..99: >
EXPR_STMT@100..102: b;
IDENTIFIER@100..101: b
OLD_STYLE_DECLARATION_STATEMENT@103..112: creg a[1]
INDEXED_IDENTIFIER@108..112: a[1]
INDEX_OPERATOR@109..112: [1]
EXPRESSION_LIST@110..111: 1
LITERAL@110..111: 1
ERROR@113..114: =
EXPR_STMT@115..126: measure $0;
MEASURE_EXPRESSION@115..125: measure $0
HARDWARE_QUBIT@123..125: $0
EXPR_STMT@127..140: measure $0 ->
BIN_EXPR@127..140: measure $0 ->
MEASURE_EXPRESSION@127..137: measure $0
HARDWARE_QUBIT@135..137: $0
ERROR@139..140: >
OLD_STYLE_DECLARATION_STATEMENT@141..151: creg a[1];
INDEXED_IDENTIFIER@146..150: a[1]
INDEX_OPERATOR@147..150: [1]
EXPRESSION_LIST@148..149: 1
LITERAL@148..149: 1
EXPR_STMT@152..165: measure $0 ->
BIN_EXPR@152..165: measure $0 ->
MEASURE_EXPRESSION@152..162: measure $0
HARDWARE_QUBIT@160..162: $0
ERROR@164..165: >
CLASSICAL_DECLARATION_STATEMENT@166..175: bit[1] a;
SCALAR_TYPE@166..172: bit[1]
DESIGNATOR@169..172: [1]
LITERAL@170..171: 1
NAME@173..174: a
EXPR_STMT@221..240: a = 2 * measure $0;
BIN_EXPR@221..239: a = 2 * measure $0
ASSIGNMENT_STMT@221..226: a = 2
IDENTIFIER@221..222: a
LITERAL@225..226: 2
MEASURE_EXPRESSION@229..239: measure $0
HARDWARE_QUBIT@237..239: $0
EXPR_STMT@241..273: a = (measure $0) + (measure $1);
BIN_EXPR@241..272: a = (measure $0) + (measure $1)
ASSIGNMENT_STMT@241..257: a = (measure $0)
IDENTIFIER@241..242: a
PAREN_EXPR@245..257: (measure $0)
MEASURE_EXPRESSION@246..256: measure $0
HARDWARE_QUBIT@254..256: $0
PAREN_EXPR@260..272: (measure $1)
MEASURE_EXPRESSION@261..271: measure $1
HARDWARE_QUBIT@269..271: $1
