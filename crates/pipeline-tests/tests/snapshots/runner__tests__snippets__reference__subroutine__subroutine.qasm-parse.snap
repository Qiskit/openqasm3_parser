---
source: crates/pipeline-tests/tests/runner.rs
expression: parse_snap
---
id: tests/snippets/reference/subroutine/subroutine.qasm
expect-parse: Todo
--- parser ---
ok: false
panicked: false
errors: 14
--- ast ---
SOURCE_FILE@0..293: 
def test_sub1(int[5] i, qubit[2] q1, qreg q2[5]) -> int[10] {
  int[10] result;
  if (result == 2) return 1 + result;
  return result;
}
def test_sub2(int[5] i, bit[2] b, creg c[3]) {
  for int[5] j in {2, 3}
    i += j;
  return i+1;
}
def returns_a_measure(qubit q) {
  return measure q;
}

DEF@1..37: def test_sub1(int[5] i, qubit[2] q1,
NAME@5..14: test_sub1
TYPED_PARAM_LIST@14..37: (int[5] i, qubit[2] q1,
TYPED_PARAM@15..23: int[5] i
SCALAR_TYPE@15..21: int[5]
DESIGNATOR@18..21: [5]
LITERAL@19..20: 5
NAME@22..23: i
TYPED_PARAM@25..36: qubit[2] q1
SCALAR_TYPE@25..33: qubit[2]
DESIGNATOR@30..33: [2]
LITERAL@31..32: 2
NAME@34..36: q1
OLD_STYLE_DECLARATION_STATEMENT@38..48: qreg q2[5]
INDEXED_IDENTIFIER@43..48: q2[5]
INDEX_OPERATOR@45..48: [5]
EXPRESSION_LIST@46..47: 5
LITERAL@46..47: 5
ERROR@48..49: )
EXPR_STMT@50..52: ->
PREFIX_EXPR@50..52: ->
ERROR@51..52: >
SCALAR_TYPE@53..60: int[10]
DESIGNATOR@56..60: [10]
LITERAL@57..59: 10
NAME@61..61: 
EXPR_STMT@61..137: {
  int[10] result;
  if (result == 2) return 1 + result;
  return result;
}
BLOCK_EXPR@61..137: {
  int[10] result;
  if (result == 2) return 1 + result;
  return result;
}
CLASSICAL_DECLARATION_STATEMENT@65..80: int[10] result;
SCALAR_TYPE@65..72: int[10]
DESIGNATOR@68..72: [10]
LITERAL@69..71: 10
NAME@73..79: result
IF_STMT@83..118: if (result == 2) return 1 + result;
BIN_EXPR@87..98: result == 2
IDENTIFIER@87..93: result
LITERAL@97..98: 2
EXPR_STMT@100..118: return 1 + result;
RETURN_EXPR@100..117: return 1 + result
BIN_EXPR@107..117: 1 + result
LITERAL@107..108: 1
IDENTIFIER@111..117: result
EXPR_STMT@121..135: return result;
RETURN_EXPR@121..134: return result
IDENTIFIER@128..134: result
DEF@138..171: def test_sub2(int[5] i, bit[2] b,
NAME@142..151: test_sub2
TYPED_PARAM_LIST@151..171: (int[5] i, bit[2] b,
TYPED_PARAM@152..160: int[5] i
SCALAR_TYPE@152..158: int[5]
DESIGNATOR@155..158: [5]
LITERAL@156..157: 5
NAME@159..160: i
TYPED_PARAM@162..170: bit[2] b
SCALAR_TYPE@162..168: bit[2]
DESIGNATOR@165..168: [2]
LITERAL@166..167: 2
NAME@169..170: b
OLD_STYLE_DECLARATION_STATEMENT@172..181: creg c[3]
INDEXED_IDENTIFIER@177..181: c[3]
INDEX_OPERATOR@178..181: [3]
EXPRESSION_LIST@179..180: 3
LITERAL@179..180: 3
ERROR@181..182: )
EXPR_STMT@183..237: {
  for int[5] j in {2, 3}
    i += j;
  return i+1;
}
BLOCK_EXPR@183..237: {
  for int[5] j in {2, 3}
    i += j;
  return i+1;
}
FOR_STMT@187..221: for int[5] j in {2, 3}
    i += j;
SCALAR_TYPE@191..197: int[5]
DESIGNATOR@194..197: [5]
LITERAL@195..196: 5
NAME@198..199: j
FOR_ITERABLE@203..209: {2, 3}
SET_EXPRESSION@203..209: {2, 3}
EXPRESSION_LIST@204..208: 2, 3
LITERAL@204..205: 2
LITERAL@207..208: 3
EXPR_STMT@214..221: i += j;
BIN_EXPR@214..220: i += j
IDENTIFIER@214..215: i
IDENTIFIER@219..220: j
EXPR_STMT@224..235: return i+1;
RETURN_EXPR@224..234: return i+1
BIN_EXPR@231..234: i+1
IDENTIFIER@231..232: i
LITERAL@233..234: 1
DEF@238..292: def returns_a_measure(qubit q) {
  return measure q;
}
NAME@242..259: returns_a_measure
TYPED_PARAM_LIST@259..268: (qubit q)
TYPED_PARAM@260..267: qubit q
SCALAR_TYPE@260..265: qubit
NAME@266..267: q
BLOCK_EXPR@269..292: {
  return measure q;
}
EXPR_STMT@273..290: return measure q;
RETURN_EXPR@273..289: return measure q
MEASURE_EXPRESSION@280..289: measure q
IDENTIFIER@288..289: q
