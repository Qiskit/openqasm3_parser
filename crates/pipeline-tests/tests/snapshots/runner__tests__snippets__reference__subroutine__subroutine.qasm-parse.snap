---
source: crates/pipeline-tests/tests/runner.rs
expression: parse_snap
---
id: tests/snippets/reference/subroutine/subroutine.qasm
expect-parse: Todo
--- parser ---
ok: false
panicked: false
errors: 16
--- ast ---
SOURCE_FILE@0..333: // lex: ok
// parse: todo
// sema: todo

def test_sub1(int[5] i, qubit[2] q1, qreg q2[5]) -> int[10] {
  int[10] result;
  if (result == 2) return 1 + result;
  return result;
}
def test_sub2(int[5] i, bit[2] b, creg c[3]) {
  for int[5] j in {2, 3}
    i += j;
  return i+1;
}
def returns_a_measure(qubit q) {
  return measure q;
}

DEF@41..77: def test_sub1(int[5] i, qubit[2] q1,
NAME@45..54: test_sub1
TYPED_PARAM_LIST@54..77: (int[5] i, qubit[2] q1,
TYPED_PARAM@55..63: int[5] i
SCALAR_TYPE@55..61: int[5]
DESIGNATOR@58..61: [5]
LITERAL@59..60: 5
NAME@62..63: i
TYPED_PARAM@65..76: qubit[2] q1
SCALAR_TYPE@65..73: qubit[2]
DESIGNATOR@70..73: [2]
LITERAL@71..72: 2
NAME@74..76: q1
ERROR@78..82: qreg
EXPR_STMT@83..88: q2[5]
INDEXED_IDENTIFIER@83..88: q2[5]
IDENTIFIER@83..85: q2
INDEX_OPERATOR@85..88: [5]
EXPRESSION_LIST@86..87: 5
LITERAL@86..87: 5
ERROR@88..89: )
EXPR_STMT@90..92: ->
PREFIX_EXPR@90..92: ->
ERROR@91..92: >
SCALAR_TYPE@93..100: int[10]
DESIGNATOR@96..100: [10]
LITERAL@97..99: 10
NAME@101..101: 
EXPR_STMT@101..177: {
  int[10] result;
  if (result == 2) return 1 + result;
  return result;
}
BLOCK_EXPR@101..177: {
  int[10] result;
  if (result == 2) return 1 + result;
  return result;
}
CLASSICAL_DECLARATION_STATEMENT@105..120: int[10] result;
SCALAR_TYPE@105..112: int[10]
DESIGNATOR@108..112: [10]
LITERAL@109..111: 10
NAME@113..119: result
IF_STMT@123..158: if (result == 2) return 1 + result;
BIN_EXPR@127..138: result == 2
IDENTIFIER@127..133: result
LITERAL@137..138: 2
EXPR_STMT@140..158: return 1 + result;
RETURN_EXPR@140..157: return 1 + result
BIN_EXPR@147..157: 1 + result
LITERAL@147..148: 1
IDENTIFIER@151..157: result
EXPR_STMT@161..175: return result;
RETURN_EXPR@161..174: return result
IDENTIFIER@168..174: result
DEF@178..211: def test_sub2(int[5] i, bit[2] b,
NAME@182..191: test_sub2
TYPED_PARAM_LIST@191..211: (int[5] i, bit[2] b,
TYPED_PARAM@192..200: int[5] i
SCALAR_TYPE@192..198: int[5]
DESIGNATOR@195..198: [5]
LITERAL@196..197: 5
NAME@199..200: i
TYPED_PARAM@202..210: bit[2] b
SCALAR_TYPE@202..208: bit[2]
DESIGNATOR@205..208: [2]
LITERAL@206..207: 2
NAME@209..210: b
ERROR@212..216: creg
EXPR_STMT@217..221: c[3]
INDEXED_IDENTIFIER@217..221: c[3]
IDENTIFIER@217..218: c
INDEX_OPERATOR@218..221: [3]
EXPRESSION_LIST@219..220: 3
LITERAL@219..220: 3
ERROR@221..222: )
EXPR_STMT@223..277: {
  for int[5] j in {2, 3}
    i += j;
  return i+1;
}
BLOCK_EXPR@223..277: {
  for int[5] j in {2, 3}
    i += j;
  return i+1;
}
FOR_STMT@227..261: for int[5] j in {2, 3}
    i += j;
SCALAR_TYPE@231..237: int[5]
DESIGNATOR@234..237: [5]
LITERAL@235..236: 5
NAME@238..239: j
FOR_ITERABLE@243..249: {2, 3}
SET_EXPRESSION@243..249: {2, 3}
EXPRESSION_LIST@244..248: 2, 3
LITERAL@244..245: 2
LITERAL@247..248: 3
EXPR_STMT@254..261: i += j;
BIN_EXPR@254..260: i += j
IDENTIFIER@254..255: i
IDENTIFIER@259..260: j
EXPR_STMT@264..275: return i+1;
RETURN_EXPR@264..274: return i+1
BIN_EXPR@271..274: i+1
IDENTIFIER@271..272: i
LITERAL@273..274: 1
DEF@278..332: def returns_a_measure(qubit q) {
  return measure q;
}
NAME@282..299: returns_a_measure
TYPED_PARAM_LIST@299..308: (qubit q)
TYPED_PARAM@300..307: qubit q
SCALAR_TYPE@300..305: qubit
NAME@306..307: q
BLOCK_EXPR@309..332: {
  return measure q;
}
EXPR_STMT@313..330: return measure q;
RETURN_EXPR@313..329: return measure q
MEASURE_EXPRESSION@320..329: measure q
IDENTIFIER@328..329: q
