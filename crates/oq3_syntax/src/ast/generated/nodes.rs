//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(non_snake_case)]
use crate::{
    ast::{self, support, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}
impl Name {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}
impl SourceFile {
    pub fn statements(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AliasDeclarationStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for AliasDeclarationStatement {}
impl AliasDeclarationStatement {
    pub fn let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![let])
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignmentStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for AssignmentStmt {}
impl AssignmentStmt {
    pub fn indexed_identifier(&self) -> Option<IndexedIdentifier> {
        support::child(&self.syntax)
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Barrier {
    pub(crate) syntax: SyntaxNode,
}
impl Barrier {
    pub fn barrier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![barrier])
    }
    pub fn qubit_list(&self) -> Option<QubitList> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakStmt {
    pub(crate) syntax: SyntaxNode,
}
impl BreakStmt {
    pub fn break_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![break])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Cal {
    pub(crate) syntax: SyntaxNode,
}
impl Cal {
    pub fn cal_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![cal])
    }
    pub fn body(&self) -> Option<BlockExpr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClassicalDeclarationStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for ClassicalDeclarationStatement {}
impl ClassicalDeclarationStatement {
    pub fn const_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![const])
    }
    pub fn scalar_type(&self) -> Option<ScalarType> {
        support::child(&self.syntax)
    }
    pub fn array_type(&self) -> Option<ArrayType> {
        support::child(&self.syntax)
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ContinueStmt {
    pub fn continue_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![continue])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Def {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for Def {}
impl Def {
    pub fn def_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![def])
    }
    pub fn param_list(&self) -> Option<ParamList> {
        support::child(&self.syntax)
    }
    pub fn return_signature(&self) -> Option<ReturnSignature> {
        support::child(&self.syntax)
    }
    pub fn body(&self) -> Option<BlockExpr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefCal {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for DefCal {}
impl DefCal {
    pub fn defcal_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![defcal])
    }
    pub fn param_list(&self) -> Option<ParamList> {
        support::child(&self.syntax)
    }
    pub fn qubit_list(&self) -> Option<QubitList> {
        support::child(&self.syntax)
    }
    pub fn return_signature(&self) -> Option<ReturnSignature> {
        support::child(&self.syntax)
    }
    pub fn body(&self) -> Option<BlockExpr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefCalGrammar {
    pub(crate) syntax: SyntaxNode,
}
impl DefCalGrammar {
    pub fn defcalgrammar_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![defcalgrammar])
    }
    pub fn file(&self) -> Option<FilePath> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EndStmt {
    pub(crate) syntax: SyntaxNode,
}
impl EndStmt {
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![end])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ExprStmt {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ForStmt {
    pub fn for_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![for])
    }
    pub fn loop_var(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
    pub fn in_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![in])
    }
    pub fn loop_body(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Gate {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for Gate {}
impl Gate {
    pub fn gate_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![gate])
    }
    pub fn qubit_args(&self) -> Option<ParamList> {
        support::child(&self.syntax)
    }
    pub fn body(&self) -> Option<BlockExpr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfStmt {
    pub(crate) syntax: SyntaxNode,
}
impl IfStmt {
    pub fn if_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![if])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn else_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![else])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Include {
    pub(crate) syntax: SyntaxNode,
}
impl Include {
    pub fn include_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![include])
    }
    pub fn file(&self) -> Option<FilePath> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for LetStmt {}
impl LetStmt {
    pub fn let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![let])
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Measure {
    pub(crate) syntax: SyntaxNode,
}
impl Measure {
    pub fn measure_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![measure])
    }
    pub fn qubit(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QuantumDeclarationStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for QuantumDeclarationStatement {}
impl QuantumDeclarationStatement {
    pub fn qubit_type(&self) -> Option<QubitType> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Reset {
    pub(crate) syntax: SyntaxNode,
}
impl Reset {
    pub fn reset_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![reset])
    }
    pub fn qubit(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SwitchCaseStmt {
    pub(crate) syntax: SyntaxNode,
}
impl SwitchCaseStmt {
    pub fn switch_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![switch])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn control(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn case_exprs(&self) -> AstChildren<CaseExpr> {
        support::children(&self.syntax)
    }
    pub fn default_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![default])
    }
    pub fn default_block(&self) -> Option<BlockExpr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeDeclarationStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for TypeDeclarationStmt {}
impl TypeDeclarationStmt {
    pub fn type_spec(&self) -> Option<TypeSpec> {
        support::child(&self.syntax)
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VersionString {
    pub(crate) syntax: SyntaxNode,
}
impl VersionString {
    pub fn OPENQASM_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![OPENQASM])
    }
    pub fn version(&self) -> Option<Version> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileStmt {
    pub(crate) syntax: SyntaxNode,
}
impl WhileStmt {
    pub fn while_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![while])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn loop_body(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CaseExpr {
    pub(crate) syntax: SyntaxNode,
}
impl CaseExpr {
    pub fn case_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![case])
    }
    pub fn expression_list(&self) -> Option<ExpressionList> {
        support::child(&self.syntax)
    }
    pub fn block_expr(&self) -> Option<BlockExpr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BlockExpr {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn statements(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExpressionList {
    pub(crate) syntax: SyntaxNode,
}
impl ExpressionList {
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Version {
    pub(crate) syntax: SyntaxNode,
}
impl Version {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QubitList {
    pub(crate) syntax: SyntaxNode,
}
impl QubitList {
    pub fn gate_operands(&self) -> AstChildren<GateOperand> {
        support::children(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FilePath {
    pub(crate) syntax: SyntaxNode,
}
impl FilePath {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeSpec {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for TypeSpec {}
impl TypeSpec {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamList {
    pub(crate) syntax: SyntaxNode,
}
impl ParamList {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn params(&self) -> AstChildren<Param> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnSignature {
    pub(crate) syntax: SyntaxNode,
}
impl ReturnSignature {
    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![->])
    }
    pub fn scalar_type(&self) -> Option<ScalarType> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for Param {}
impl Param {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ArrayExpr {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayLiteral {
    pub(crate) syntax: SyntaxNode,
}
impl ArrayLiteral {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn expression_list(&self) -> Option<ExpressionList> {
        support::child(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BinExpr {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BoxExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BoxExpr {
    pub fn box_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![box])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasArgList for CallExpr {}
impl CallExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CastExpression {
    pub(crate) syntax: SyntaxNode,
}
impl CastExpression {
    pub fn scalar_type(&self) -> Option<ScalarType> {
        support::child(&self.syntax)
    }
    pub fn array_type(&self) -> Option<ArrayType> {
        support::child(&self.syntax)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GateCallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for GateCallExpr {}
impl ast::HasArgList for GateCallExpr {}
impl GateCallExpr {
    pub fn qubit_list(&self) -> Option<QubitList> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GPhaseCallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl GPhaseCallExpr {
    pub fn gphase_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![gphase])
    }
    pub fn arg(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct HardwareQubit {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for HardwareQubit {}
impl HardwareQubit {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Identifier {
    pub(crate) syntax: SyntaxNode,
}
impl Identifier {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr {
    pub(crate) syntax: SyntaxNode,
}
impl IndexExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn index_operator(&self) -> Option<IndexOperator> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexedIdentifier {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for IndexedIdentifier {}
impl IndexedIdentifier {
    pub fn index_operators(&self) -> AstChildren<IndexOperator> {
        support::children(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}
impl Literal {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MeasureExpression {
    pub(crate) syntax: SyntaxNode,
}
impl MeasureExpression {
    pub fn measure_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![measure])
    }
    pub fn gate_operand(&self) -> Option<GateOperand> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModifiedGateCallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ModifiedGateCallExpr {
    pub fn modifier(&self) -> Option<Modifier> {
        support::child(&self.syntax)
    }
    pub fn modifiers(&self) -> AstChildren<Modifier> {
        support::children(&self.syntax)
    }
    pub fn gate_call_expr(&self) -> Option<GateCallExpr> {
        support::child(&self.syntax)
    }
    pub fn g_phase_call_expr(&self) -> Option<GPhaseCallExpr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ParenExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpr {
    pub(crate) syntax: SyntaxNode,
}
impl RangeExpr {
    pub fn thestart(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn step(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn stop(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ReturnExpr {
    pub fn return_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![return])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexOperator {
    pub(crate) syntax: SyntaxNode,
}
impl IndexOperator {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn index_kind(&self) -> Option<IndexKind> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgList {
    pub(crate) syntax: SyntaxNode,
}
impl ArgList {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn expression_list(&self) -> Option<ExpressionList> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ScalarType {
    pub(crate) syntax: SyntaxNode,
}
impl ScalarType {
    pub fn bit_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![bit])
    }
    pub fn designator(&self) -> Option<Designator> {
        support::child(&self.syntax)
    }
    pub fn int_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![int])
    }
    pub fn uint_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![uint])
    }
    pub fn float_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![float])
    }
    pub fn angle_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![angle])
    }
    pub fn bool_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![bool])
    }
    pub fn duration_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![duration])
    }
    pub fn stretch_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![stretch])
    }
    pub fn complex_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![complex])
    }
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn scalar_type(&self) -> Option<ScalarType> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayType {
    pub(crate) syntax: SyntaxNode,
}
impl ArrayType {
    pub fn array_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![array])
    }
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn scalar_type(&self) -> Option<ScalarType> {
        support::child(&self.syntax)
    }
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
    pub fn expression_list(&self) -> Option<ExpressionList> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InvModifier {
    pub(crate) syntax: SyntaxNode,
}
impl InvModifier {
    pub fn inv_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![inv])
    }
    pub fn at_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![@])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PowModifier {
    pub(crate) syntax: SyntaxNode,
}
impl PowModifier {
    pub fn pow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pow])
    }
    pub fn paren_expr(&self) -> Option<ParenExpr> {
        support::child(&self.syntax)
    }
    pub fn at_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![@])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CtrlModifier {
    pub(crate) syntax: SyntaxNode,
}
impl CtrlModifier {
    pub fn ctrl_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ctrl])
    }
    pub fn paren_expr(&self) -> Option<ParenExpr> {
        support::child(&self.syntax)
    }
    pub fn at_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![@])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NegCtrlModifier {
    pub(crate) syntax: SyntaxNode,
}
impl NegCtrlModifier {
    pub fn negctrl_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![negctrl])
    }
    pub fn paren_expr(&self) -> Option<ParenExpr> {
        support::child(&self.syntax)
    }
    pub fn at_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![@])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Designator {
    pub(crate) syntax: SyntaxNode,
}
impl Designator {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QubitType {
    pub(crate) syntax: SyntaxNode,
}
impl QubitType {
    pub fn qubit_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![qubit])
    }
    pub fn designator(&self) -> Option<Designator> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SetExpression {
    pub(crate) syntax: SyntaxNode,
}
impl SetExpression {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn expression_list(&self) -> Option<ExpressionList> {
        support::child(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IODeclarationStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for IODeclarationStatement {}
impl IODeclarationStatement {
    pub fn input_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![input])
    }
    pub fn output_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![output])
    }
    pub fn scalar_type(&self) -> Option<ScalarType> {
        support::child(&self.syntax)
    }
    pub fn array_type(&self) -> Option<ArrayType> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OldStyleDeclarationStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for OldStyleDeclarationStatement {}
impl OldStyleDeclarationStatement {
    pub fn creg_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![creg])
    }
    pub fn qreg_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![qreg])
    }
    pub fn designator(&self) -> Option<Designator> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    AliasDeclarationStatement(AliasDeclarationStatement),
    AssignmentStmt(AssignmentStmt),
    Barrier(Barrier),
    BreakStmt(BreakStmt),
    Cal(Cal),
    ClassicalDeclarationStatement(ClassicalDeclarationStatement),
    ContinueStmt(ContinueStmt),
    Def(Def),
    DefCal(DefCal),
    DefCalGrammar(DefCalGrammar),
    EndStmt(EndStmt),
    ExprStmt(ExprStmt),
    ForStmt(ForStmt),
    Gate(Gate),
    IfStmt(IfStmt),
    Include(Include),
    LetStmt(LetStmt),
    Measure(Measure),
    QuantumDeclarationStatement(QuantumDeclarationStatement),
    Reset(Reset),
    SwitchCaseStmt(SwitchCaseStmt),
    TypeDeclarationStmt(TypeDeclarationStmt),
    VersionString(VersionString),
    WhileStmt(WhileStmt),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    ArrayExpr(ArrayExpr),
    ArrayLiteral(ArrayLiteral),
    BinExpr(BinExpr),
    BlockExpr(BlockExpr),
    BoxExpr(BoxExpr),
    CallExpr(CallExpr),
    CastExpression(CastExpression),
    GateCallExpr(GateCallExpr),
    GPhaseCallExpr(GPhaseCallExpr),
    HardwareQubit(HardwareQubit),
    Identifier(Identifier),
    IndexExpr(IndexExpr),
    IndexedIdentifier(IndexedIdentifier),
    Literal(Literal),
    MeasureExpression(MeasureExpression),
    ModifiedGateCallExpr(ModifiedGateCallExpr),
    ParenExpr(ParenExpr),
    PrefixExpr(PrefixExpr),
    RangeExpr(RangeExpr),
    ReturnExpr(ReturnExpr),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GateOperand {
    Identifier(Identifier),
    IndexedIdentifier(IndexedIdentifier),
    HardwareQubit(HardwareQubit),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Modifier {
    InvModifier(InvModifier),
    PowModifier(PowModifier),
    CtrlModifier(CtrlModifier),
    NegCtrlModifier(NegCtrlModifier),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum IndexKind {
    SetExpression(SetExpression),
    ExpressionList(ExpressionList),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasArgList {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasArgList for AnyHasArgList {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasName {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for AnyHasName {}
impl AstNode for Name {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAME
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SourceFile {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SOURCE_FILE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AliasDeclarationStatement {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ALIAS_DECLARATION_STATEMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssignmentStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSIGNMENT_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Barrier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BARRIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BreakStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BREAK_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Cal {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ClassicalDeclarationStatement {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CLASSICAL_DECLARATION_STATEMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ContinueStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONTINUE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Def {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEF
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DefCal {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEF_CAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DefCalGrammar {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEF_CAL_GRAMMAR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for EndStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == END_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExprStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPR_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ForStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FOR_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Gate {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == GATE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IfStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IF_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Include {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INCLUDE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Measure {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MEASURE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for QuantumDeclarationStatement {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == QUANTUM_DECLARATION_STATEMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Reset {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RESET
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SwitchCaseStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SWITCH_CASE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TypeDeclarationStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_DECLARATION_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VersionString {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VERSION_STRING
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WhileStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WHILE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CaseExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CASE_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BlockExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BLOCK_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExpressionList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPRESSION_LIST
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Version {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VERSION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for QubitList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == QUBIT_LIST
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FilePath {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FILE_PATH
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TypeSpec {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_SPEC
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ParamList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PARAM_LIST
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ReturnSignature {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RETURN_SIGNATURE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Param {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PARAM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ArrayExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARRAY_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ArrayLiteral {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARRAY_LITERAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BinExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BIN_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BoxExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BOX_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CallExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CALL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CastExpression {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CAST_EXPRESSION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for GateCallExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == GATE_CALL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for GPhaseCallExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == G_PHASE_CALL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for HardwareQubit {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == HARDWARE_QUBIT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Identifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENTIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IndexExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INDEX_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IndexedIdentifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INDEXED_IDENTIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Literal {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LITERAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MeasureExpression {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MEASURE_EXPRESSION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ModifiedGateCallExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MODIFIED_GATE_CALL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ParenExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PAREN_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for RangeExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RANGE_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ReturnExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RETURN_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IndexOperator {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INDEX_OPERATOR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ArgList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARG_LIST
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ScalarType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SCALAR_TYPE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ArrayType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARRAY_TYPE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InvModifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INV_MODIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PowModifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == POW_MODIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CtrlModifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CTRL_MODIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NegCtrlModifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NEG_CTRL_MODIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Designator {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DESIGNATOR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for QubitType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == QUBIT_TYPE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SetExpression {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SET_EXPRESSION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IODeclarationStatement {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == I_O_DECLARATION_STATEMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for OldStyleDeclarationStatement {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OLD_STYLE_DECLARATION_STATEMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl From<AliasDeclarationStatement> for Stmt {
    fn from(node: AliasDeclarationStatement) -> Stmt {
        Stmt::AliasDeclarationStatement(node)
    }
}
impl From<AssignmentStmt> for Stmt {
    fn from(node: AssignmentStmt) -> Stmt {
        Stmt::AssignmentStmt(node)
    }
}
impl From<Barrier> for Stmt {
    fn from(node: Barrier) -> Stmt {
        Stmt::Barrier(node)
    }
}
impl From<BreakStmt> for Stmt {
    fn from(node: BreakStmt) -> Stmt {
        Stmt::BreakStmt(node)
    }
}
impl From<Cal> for Stmt {
    fn from(node: Cal) -> Stmt {
        Stmt::Cal(node)
    }
}
impl From<ClassicalDeclarationStatement> for Stmt {
    fn from(node: ClassicalDeclarationStatement) -> Stmt {
        Stmt::ClassicalDeclarationStatement(node)
    }
}
impl From<ContinueStmt> for Stmt {
    fn from(node: ContinueStmt) -> Stmt {
        Stmt::ContinueStmt(node)
    }
}
impl From<Def> for Stmt {
    fn from(node: Def) -> Stmt {
        Stmt::Def(node)
    }
}
impl From<DefCal> for Stmt {
    fn from(node: DefCal) -> Stmt {
        Stmt::DefCal(node)
    }
}
impl From<DefCalGrammar> for Stmt {
    fn from(node: DefCalGrammar) -> Stmt {
        Stmt::DefCalGrammar(node)
    }
}
impl From<EndStmt> for Stmt {
    fn from(node: EndStmt) -> Stmt {
        Stmt::EndStmt(node)
    }
}
impl From<ExprStmt> for Stmt {
    fn from(node: ExprStmt) -> Stmt {
        Stmt::ExprStmt(node)
    }
}
impl From<ForStmt> for Stmt {
    fn from(node: ForStmt) -> Stmt {
        Stmt::ForStmt(node)
    }
}
impl From<Gate> for Stmt {
    fn from(node: Gate) -> Stmt {
        Stmt::Gate(node)
    }
}
impl From<IfStmt> for Stmt {
    fn from(node: IfStmt) -> Stmt {
        Stmt::IfStmt(node)
    }
}
impl From<Include> for Stmt {
    fn from(node: Include) -> Stmt {
        Stmt::Include(node)
    }
}
impl From<LetStmt> for Stmt {
    fn from(node: LetStmt) -> Stmt {
        Stmt::LetStmt(node)
    }
}
impl From<Measure> for Stmt {
    fn from(node: Measure) -> Stmt {
        Stmt::Measure(node)
    }
}
impl From<QuantumDeclarationStatement> for Stmt {
    fn from(node: QuantumDeclarationStatement) -> Stmt {
        Stmt::QuantumDeclarationStatement(node)
    }
}
impl From<Reset> for Stmt {
    fn from(node: Reset) -> Stmt {
        Stmt::Reset(node)
    }
}
impl From<SwitchCaseStmt> for Stmt {
    fn from(node: SwitchCaseStmt) -> Stmt {
        Stmt::SwitchCaseStmt(node)
    }
}
impl From<TypeDeclarationStmt> for Stmt {
    fn from(node: TypeDeclarationStmt) -> Stmt {
        Stmt::TypeDeclarationStmt(node)
    }
}
impl From<VersionString> for Stmt {
    fn from(node: VersionString) -> Stmt {
        Stmt::VersionString(node)
    }
}
impl From<WhileStmt> for Stmt {
    fn from(node: WhileStmt) -> Stmt {
        Stmt::WhileStmt(node)
    }
}
impl AstNode for Stmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ALIAS_DECLARATION_STATEMENT
                | ASSIGNMENT_STMT
                | BARRIER
                | BREAK_STMT
                | CAL
                | CLASSICAL_DECLARATION_STATEMENT
                | CONTINUE_STMT
                | DEF
                | DEF_CAL
                | DEF_CAL_GRAMMAR
                | END_STMT
                | EXPR_STMT
                | FOR_STMT
                | GATE
                | IF_STMT
                | INCLUDE
                | LET_STMT
                | MEASURE
                | QUANTUM_DECLARATION_STATEMENT
                | RESET
                | SWITCH_CASE_STMT
                | TYPE_DECLARATION_STMT
                | VERSION_STRING
                | WHILE_STMT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ALIAS_DECLARATION_STATEMENT => {
                Stmt::AliasDeclarationStatement(AliasDeclarationStatement { syntax })
            }
            ASSIGNMENT_STMT => Stmt::AssignmentStmt(AssignmentStmt { syntax }),
            BARRIER => Stmt::Barrier(Barrier { syntax }),
            BREAK_STMT => Stmt::BreakStmt(BreakStmt { syntax }),
            CAL => Stmt::Cal(Cal { syntax }),
            CLASSICAL_DECLARATION_STATEMENT => {
                Stmt::ClassicalDeclarationStatement(ClassicalDeclarationStatement { syntax })
            }
            CONTINUE_STMT => Stmt::ContinueStmt(ContinueStmt { syntax }),
            DEF => Stmt::Def(Def { syntax }),
            DEF_CAL => Stmt::DefCal(DefCal { syntax }),
            DEF_CAL_GRAMMAR => Stmt::DefCalGrammar(DefCalGrammar { syntax }),
            END_STMT => Stmt::EndStmt(EndStmt { syntax }),
            EXPR_STMT => Stmt::ExprStmt(ExprStmt { syntax }),
            FOR_STMT => Stmt::ForStmt(ForStmt { syntax }),
            GATE => Stmt::Gate(Gate { syntax }),
            IF_STMT => Stmt::IfStmt(IfStmt { syntax }),
            INCLUDE => Stmt::Include(Include { syntax }),
            LET_STMT => Stmt::LetStmt(LetStmt { syntax }),
            MEASURE => Stmt::Measure(Measure { syntax }),
            QUANTUM_DECLARATION_STATEMENT => {
                Stmt::QuantumDeclarationStatement(QuantumDeclarationStatement { syntax })
            }
            RESET => Stmt::Reset(Reset { syntax }),
            SWITCH_CASE_STMT => Stmt::SwitchCaseStmt(SwitchCaseStmt { syntax }),
            TYPE_DECLARATION_STMT => Stmt::TypeDeclarationStmt(TypeDeclarationStmt { syntax }),
            VERSION_STRING => Stmt::VersionString(VersionString { syntax }),
            WHILE_STMT => Stmt::WhileStmt(WhileStmt { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Stmt::AliasDeclarationStatement(it) => &it.syntax,
            Stmt::AssignmentStmt(it) => &it.syntax,
            Stmt::Barrier(it) => &it.syntax,
            Stmt::BreakStmt(it) => &it.syntax,
            Stmt::Cal(it) => &it.syntax,
            Stmt::ClassicalDeclarationStatement(it) => &it.syntax,
            Stmt::ContinueStmt(it) => &it.syntax,
            Stmt::Def(it) => &it.syntax,
            Stmt::DefCal(it) => &it.syntax,
            Stmt::DefCalGrammar(it) => &it.syntax,
            Stmt::EndStmt(it) => &it.syntax,
            Stmt::ExprStmt(it) => &it.syntax,
            Stmt::ForStmt(it) => &it.syntax,
            Stmt::Gate(it) => &it.syntax,
            Stmt::IfStmt(it) => &it.syntax,
            Stmt::Include(it) => &it.syntax,
            Stmt::LetStmt(it) => &it.syntax,
            Stmt::Measure(it) => &it.syntax,
            Stmt::QuantumDeclarationStatement(it) => &it.syntax,
            Stmt::Reset(it) => &it.syntax,
            Stmt::SwitchCaseStmt(it) => &it.syntax,
            Stmt::TypeDeclarationStmt(it) => &it.syntax,
            Stmt::VersionString(it) => &it.syntax,
            Stmt::WhileStmt(it) => &it.syntax,
        }
    }
}
impl From<ArrayExpr> for Expr {
    fn from(node: ArrayExpr) -> Expr {
        Expr::ArrayExpr(node)
    }
}
impl From<ArrayLiteral> for Expr {
    fn from(node: ArrayLiteral) -> Expr {
        Expr::ArrayLiteral(node)
    }
}
impl From<BinExpr> for Expr {
    fn from(node: BinExpr) -> Expr {
        Expr::BinExpr(node)
    }
}
impl From<BlockExpr> for Expr {
    fn from(node: BlockExpr) -> Expr {
        Expr::BlockExpr(node)
    }
}
impl From<BoxExpr> for Expr {
    fn from(node: BoxExpr) -> Expr {
        Expr::BoxExpr(node)
    }
}
impl From<CallExpr> for Expr {
    fn from(node: CallExpr) -> Expr {
        Expr::CallExpr(node)
    }
}
impl From<CastExpression> for Expr {
    fn from(node: CastExpression) -> Expr {
        Expr::CastExpression(node)
    }
}
impl From<GateCallExpr> for Expr {
    fn from(node: GateCallExpr) -> Expr {
        Expr::GateCallExpr(node)
    }
}
impl From<GPhaseCallExpr> for Expr {
    fn from(node: GPhaseCallExpr) -> Expr {
        Expr::GPhaseCallExpr(node)
    }
}
impl From<HardwareQubit> for Expr {
    fn from(node: HardwareQubit) -> Expr {
        Expr::HardwareQubit(node)
    }
}
impl From<Identifier> for Expr {
    fn from(node: Identifier) -> Expr {
        Expr::Identifier(node)
    }
}
impl From<IndexExpr> for Expr {
    fn from(node: IndexExpr) -> Expr {
        Expr::IndexExpr(node)
    }
}
impl From<IndexedIdentifier> for Expr {
    fn from(node: IndexedIdentifier) -> Expr {
        Expr::IndexedIdentifier(node)
    }
}
impl From<Literal> for Expr {
    fn from(node: Literal) -> Expr {
        Expr::Literal(node)
    }
}
impl From<MeasureExpression> for Expr {
    fn from(node: MeasureExpression) -> Expr {
        Expr::MeasureExpression(node)
    }
}
impl From<ModifiedGateCallExpr> for Expr {
    fn from(node: ModifiedGateCallExpr) -> Expr {
        Expr::ModifiedGateCallExpr(node)
    }
}
impl From<ParenExpr> for Expr {
    fn from(node: ParenExpr) -> Expr {
        Expr::ParenExpr(node)
    }
}
impl From<PrefixExpr> for Expr {
    fn from(node: PrefixExpr) -> Expr {
        Expr::PrefixExpr(node)
    }
}
impl From<RangeExpr> for Expr {
    fn from(node: RangeExpr) -> Expr {
        Expr::RangeExpr(node)
    }
}
impl From<ReturnExpr> for Expr {
    fn from(node: ReturnExpr) -> Expr {
        Expr::ReturnExpr(node)
    }
}
impl AstNode for Expr {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ARRAY_EXPR
                | ARRAY_LITERAL
                | BIN_EXPR
                | BLOCK_EXPR
                | BOX_EXPR
                | CALL_EXPR
                | CAST_EXPRESSION
                | GATE_CALL_EXPR
                | G_PHASE_CALL_EXPR
                | HARDWARE_QUBIT
                | IDENTIFIER
                | INDEX_EXPR
                | INDEXED_IDENTIFIER
                | LITERAL
                | MEASURE_EXPRESSION
                | MODIFIED_GATE_CALL_EXPR
                | PAREN_EXPR
                | PREFIX_EXPR
                | RANGE_EXPR
                | RETURN_EXPR
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ARRAY_EXPR => Expr::ArrayExpr(ArrayExpr { syntax }),
            ARRAY_LITERAL => Expr::ArrayLiteral(ArrayLiteral { syntax }),
            BIN_EXPR => Expr::BinExpr(BinExpr { syntax }),
            BLOCK_EXPR => Expr::BlockExpr(BlockExpr { syntax }),
            BOX_EXPR => Expr::BoxExpr(BoxExpr { syntax }),
            CALL_EXPR => Expr::CallExpr(CallExpr { syntax }),
            CAST_EXPRESSION => Expr::CastExpression(CastExpression { syntax }),
            GATE_CALL_EXPR => Expr::GateCallExpr(GateCallExpr { syntax }),
            G_PHASE_CALL_EXPR => Expr::GPhaseCallExpr(GPhaseCallExpr { syntax }),
            HARDWARE_QUBIT => Expr::HardwareQubit(HardwareQubit { syntax }),
            IDENTIFIER => Expr::Identifier(Identifier { syntax }),
            INDEX_EXPR => Expr::IndexExpr(IndexExpr { syntax }),
            INDEXED_IDENTIFIER => Expr::IndexedIdentifier(IndexedIdentifier { syntax }),
            LITERAL => Expr::Literal(Literal { syntax }),
            MEASURE_EXPRESSION => Expr::MeasureExpression(MeasureExpression { syntax }),
            MODIFIED_GATE_CALL_EXPR => Expr::ModifiedGateCallExpr(ModifiedGateCallExpr { syntax }),
            PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),
            PREFIX_EXPR => Expr::PrefixExpr(PrefixExpr { syntax }),
            RANGE_EXPR => Expr::RangeExpr(RangeExpr { syntax }),
            RETURN_EXPR => Expr::ReturnExpr(ReturnExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::ArrayExpr(it) => &it.syntax,
            Expr::ArrayLiteral(it) => &it.syntax,
            Expr::BinExpr(it) => &it.syntax,
            Expr::BlockExpr(it) => &it.syntax,
            Expr::BoxExpr(it) => &it.syntax,
            Expr::CallExpr(it) => &it.syntax,
            Expr::CastExpression(it) => &it.syntax,
            Expr::GateCallExpr(it) => &it.syntax,
            Expr::GPhaseCallExpr(it) => &it.syntax,
            Expr::HardwareQubit(it) => &it.syntax,
            Expr::Identifier(it) => &it.syntax,
            Expr::IndexExpr(it) => &it.syntax,
            Expr::IndexedIdentifier(it) => &it.syntax,
            Expr::Literal(it) => &it.syntax,
            Expr::MeasureExpression(it) => &it.syntax,
            Expr::ModifiedGateCallExpr(it) => &it.syntax,
            Expr::ParenExpr(it) => &it.syntax,
            Expr::PrefixExpr(it) => &it.syntax,
            Expr::RangeExpr(it) => &it.syntax,
            Expr::ReturnExpr(it) => &it.syntax,
        }
    }
}
impl From<Identifier> for GateOperand {
    fn from(node: Identifier) -> GateOperand {
        GateOperand::Identifier(node)
    }
}
impl From<IndexedIdentifier> for GateOperand {
    fn from(node: IndexedIdentifier) -> GateOperand {
        GateOperand::IndexedIdentifier(node)
    }
}
impl From<HardwareQubit> for GateOperand {
    fn from(node: HardwareQubit) -> GateOperand {
        GateOperand::HardwareQubit(node)
    }
}
impl AstNode for GateOperand {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, IDENTIFIER | INDEXED_IDENTIFIER | HARDWARE_QUBIT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENTIFIER => GateOperand::Identifier(Identifier { syntax }),
            INDEXED_IDENTIFIER => GateOperand::IndexedIdentifier(IndexedIdentifier { syntax }),
            HARDWARE_QUBIT => GateOperand::HardwareQubit(HardwareQubit { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            GateOperand::Identifier(it) => &it.syntax,
            GateOperand::IndexedIdentifier(it) => &it.syntax,
            GateOperand::HardwareQubit(it) => &it.syntax,
        }
    }
}
impl From<InvModifier> for Modifier {
    fn from(node: InvModifier) -> Modifier {
        Modifier::InvModifier(node)
    }
}
impl From<PowModifier> for Modifier {
    fn from(node: PowModifier) -> Modifier {
        Modifier::PowModifier(node)
    }
}
impl From<CtrlModifier> for Modifier {
    fn from(node: CtrlModifier) -> Modifier {
        Modifier::CtrlModifier(node)
    }
}
impl From<NegCtrlModifier> for Modifier {
    fn from(node: NegCtrlModifier) -> Modifier {
        Modifier::NegCtrlModifier(node)
    }
}
impl AstNode for Modifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            INV_MODIFIER | POW_MODIFIER | CTRL_MODIFIER | NEG_CTRL_MODIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INV_MODIFIER => Modifier::InvModifier(InvModifier { syntax }),
            POW_MODIFIER => Modifier::PowModifier(PowModifier { syntax }),
            CTRL_MODIFIER => Modifier::CtrlModifier(CtrlModifier { syntax }),
            NEG_CTRL_MODIFIER => Modifier::NegCtrlModifier(NegCtrlModifier { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Modifier::InvModifier(it) => &it.syntax,
            Modifier::PowModifier(it) => &it.syntax,
            Modifier::CtrlModifier(it) => &it.syntax,
            Modifier::NegCtrlModifier(it) => &it.syntax,
        }
    }
}
impl From<SetExpression> for IndexKind {
    fn from(node: SetExpression) -> IndexKind {
        IndexKind::SetExpression(node)
    }
}
impl From<ExpressionList> for IndexKind {
    fn from(node: ExpressionList) -> IndexKind {
        IndexKind::ExpressionList(node)
    }
}
impl AstNode for IndexKind {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, SET_EXPRESSION | EXPRESSION_LIST)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            SET_EXPRESSION => IndexKind::SetExpression(SetExpression { syntax }),
            EXPRESSION_LIST => IndexKind::ExpressionList(ExpressionList { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            IndexKind::SetExpression(it) => &it.syntax,
            IndexKind::ExpressionList(it) => &it.syntax,
        }
    }
}
impl AnyHasArgList {
    #[inline]
    pub fn new<T: ast::HasArgList>(node: T) -> AnyHasArgList {
        AnyHasArgList {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasArgList {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, CALL_EXPR | GATE_CALL_EXPR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasArgList { syntax })
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AnyHasName {
    #[inline]
    pub fn new<T: ast::HasName>(node: T) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasName {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ALIAS_DECLARATION_STATEMENT
                | ASSIGNMENT_STMT
                | CLASSICAL_DECLARATION_STATEMENT
                | DEF
                | DEF_CAL
                | GATE
                | LET_STMT
                | QUANTUM_DECLARATION_STATEMENT
                | TYPE_DECLARATION_STMT
                | TYPE_SPEC
                | PARAM
                | GATE_CALL_EXPR
                | HARDWARE_QUBIT
                | INDEXED_IDENTIFIER
                | I_O_DECLARATION_STATEMENT
                | OLD_STYLE_DECLARATION_STATEMENT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasName { syntax })
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GateOperand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Modifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IndexKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SourceFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AliasDeclarationStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssignmentStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Barrier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BreakStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Cal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClassicalDeclarationStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ContinueStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Def {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefCal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefCalGrammar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EndStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExprStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Gate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IfStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Include {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Measure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for QuantumDeclarationStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Reset {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SwitchCaseStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeDeclarationStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VersionString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WhileStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CaseExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BlockExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExpressionList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Version {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for QubitList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FilePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParamList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ReturnSignature {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Param {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArrayExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArrayLiteral {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BoxExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CastExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GateCallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GPhaseCallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for HardwareQubit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Identifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IndexExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IndexedIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MeasureExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ModifiedGateCallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParenExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RangeExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ReturnExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IndexOperator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ScalarType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArrayType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InvModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PowModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CtrlModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NegCtrlModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Designator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for QubitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SetExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IODeclarationStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OldStyleDeclarationStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
