//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(non_snake_case)]
use crate::{
    ast::{self, support, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}
impl Name {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasModuleItem for SourceFile {}
impl SourceFile {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Def {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for Def {}
impl Def {
    pub fn def_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![def])
    }
    pub fn param_list(&self) -> Option<ParamList> {
        support::child(&self.syntax)
    }
    pub fn ret_type(&self) -> Option<RetType> {
        support::child(&self.syntax)
    }
    pub fn body(&self) -> Option<BlockExpr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Gate {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for Gate {}
impl Gate {
    pub fn gate_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![gate])
    }
    pub fn qubit_args(&self) -> Option<ParamList> {
        support::child(&self.syntax)
    }
    pub fn body(&self) -> Option<BlockExpr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefCal {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for DefCal {}
impl DefCal {
    pub fn defcal_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![defcal])
    }
    pub fn param_list(&self) -> Option<ParamList> {
        support::child(&self.syntax)
    }
    pub fn qubit_list(&self) -> Option<QubitList> {
        support::child(&self.syntax)
    }
    pub fn ret_type(&self) -> Option<RetType> {
        support::child(&self.syntax)
    }
    pub fn body(&self) -> Option<BlockExpr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Cal {
    pub(crate) syntax: SyntaxNode,
}
impl Cal {
    pub fn cal_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![cal])
    }
    pub fn body(&self) -> Option<BlockExpr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefCalGrammar {
    pub(crate) syntax: SyntaxNode,
}
impl DefCalGrammar {
    pub fn defcalgrammar_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![defcalgrammar])
    }
    pub fn file(&self) -> Option<FilePath> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeDeclarationStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for TypeDeclarationStmt {}
impl TypeDeclarationStmt {
    pub fn type_spec(&self) -> Option<TypeSpec> {
        support::child(&self.syntax)
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClassicalDeclarationStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for ClassicalDeclarationStatement {}
impl ClassicalDeclarationStatement {
    pub fn const_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![const])
    }
    pub fn scalar_type(&self) -> Option<ScalarType> {
        support::child(&self.syntax)
    }
    pub fn array_type(&self) -> Option<ArrayType> {
        support::child(&self.syntax)
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QuantumDeclarationStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for QuantumDeclarationStatement {}
impl QuantumDeclarationStatement {
    pub fn qubit_type(&self) -> Option<QubitType> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GPhaseCallStmt {
    pub(crate) syntax: SyntaxNode,
}
impl GPhaseCallStmt {
    pub fn gphase_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![gphase])
    }
    pub fn arg(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for LetStmt {}
impl LetStmt {
    pub fn let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![let])
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignmentStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for AssignmentStmt {}
impl AssignmentStmt {
    pub fn indexed_identifier(&self) -> Option<IndexedIdentifier> {
        support::child(&self.syntax)
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Include {
    pub(crate) syntax: SyntaxNode,
}
impl Include {
    pub fn include_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![include])
    }
    pub fn file(&self) -> Option<FilePath> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ForStmt {
    pub fn for_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![for])
    }
    pub fn loop_var(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
    pub fn in_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![in])
    }
    pub fn loop_body(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfStmt {
    pub(crate) syntax: SyntaxNode,
}
impl IfStmt {
    pub fn if_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![if])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn else_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![else])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileStmt {
    pub(crate) syntax: SyntaxNode,
}
impl WhileStmt {
    pub fn while_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![while])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn loop_body(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Reset {
    pub(crate) syntax: SyntaxNode,
}
impl Reset {
    pub fn reset_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![reset])
    }
    pub fn qubit(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Measure {
    pub(crate) syntax: SyntaxNode,
}
impl Measure {
    pub fn measure_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![measure])
    }
    pub fn qubit(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Barrier {
    pub(crate) syntax: SyntaxNode,
}
impl Barrier {
    pub fn barrier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![barrier])
    }
    pub fn qubit_list(&self) -> Option<QubitList> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VersionString {
    pub(crate) syntax: SyntaxNode,
}
impl VersionString {
    pub fn OPENQASM_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![OPENQASM])
    }
    pub fn version(&self) -> Option<Version> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakStmt {
    pub(crate) syntax: SyntaxNode,
}
impl BreakStmt {
    pub fn break_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![break])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ContinueStmt {
    pub fn continue_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![continue])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EndStmt {
    pub(crate) syntax: SyntaxNode,
}
impl EndStmt {
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![end])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Version {
    pub(crate) syntax: SyntaxNode,
}
impl Version {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QubitList {
    pub(crate) syntax: SyntaxNode,
}
impl QubitList {
    pub fn gate_operands(&self) -> AstChildren<GateOperand> {
        support::children(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BlockExpr {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn statements(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FilePath {
    pub(crate) syntax: SyntaxNode,
}
impl FilePath {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeSpec {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for TypeSpec {}
impl TypeSpec {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamList {
    pub(crate) syntax: SyntaxNode,
}
impl ParamList {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn params(&self) -> AstChildren<Param> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RetType {
    pub(crate) syntax: SyntaxNode,
}
impl RetType {
    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![->])
    }
    pub fn scalar_type(&self) -> Option<ScalarType> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for Param {}
impl Param {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternItem {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for ExternItem {}
impl ExternItem {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ExprStmt {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ArrayExpr {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayLiteral {
    pub(crate) syntax: SyntaxNode,
}
impl ArrayLiteral {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn expression_list(&self) -> Option<ExpressionList> {
        support::child(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BinExpr {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BoxExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BoxExpr {
    pub fn box_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![box])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasArgList for CallExpr {}
impl CallExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CastExpression {
    pub(crate) syntax: SyntaxNode,
}
impl CastExpression {
    pub fn scalar_type(&self) -> Option<ScalarType> {
        support::child(&self.syntax)
    }
    pub fn array_type(&self) -> Option<ArrayType> {
        support::child(&self.syntax)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GateCallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for GateCallExpr {}
impl ast::HasArgList for GateCallExpr {}
impl GateCallExpr {
    pub fn qubit_list(&self) -> Option<QubitList> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct HardwareQubit {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for HardwareQubit {}
impl HardwareQubit {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Identifier {
    pub(crate) syntax: SyntaxNode,
}
impl Identifier {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr {
    pub(crate) syntax: SyntaxNode,
}
impl IndexExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn index_operator(&self) -> Option<IndexOperator> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexedIdentifier {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for IndexedIdentifier {}
impl IndexedIdentifier {
    pub fn index_operators(&self) -> AstChildren<IndexOperator> {
        support::children(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}
impl Literal {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MeasureExpression {
    pub(crate) syntax: SyntaxNode,
}
impl MeasureExpression {
    pub fn measure_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![measure])
    }
    pub fn gate_operand(&self) -> Option<GateOperand> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModifiedGateCallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ModifiedGateCallExpr {
    pub fn modifier(&self) -> Option<Modifier> {
        support::child(&self.syntax)
    }
    pub fn modifiers(&self) -> AstChildren<Modifier> {
        support::children(&self.syntax)
    }
    pub fn gate_call_expr(&self) -> Option<GateCallExpr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ParenExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpr {
    pub(crate) syntax: SyntaxNode,
}
impl RangeExpr {
    pub fn thestart(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn step(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn stop(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ReturnExpr {
    pub fn return_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![return])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConcatenationExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ConcatenationExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn double_plus_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![++])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexOperator {
    pub(crate) syntax: SyntaxNode,
}
impl IndexOperator {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn index_kind(&self) -> Option<IndexKind> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgList {
    pub(crate) syntax: SyntaxNode,
}
impl ArgList {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn expression_list(&self) -> Option<ExpressionList> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExpressionList {
    pub(crate) syntax: SyntaxNode,
}
impl ExpressionList {
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ScalarType {
    pub(crate) syntax: SyntaxNode,
}
impl ScalarType {
    pub fn bit_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![bit])
    }
    pub fn designator(&self) -> Option<Designator> {
        support::child(&self.syntax)
    }
    pub fn int_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![int])
    }
    pub fn uint_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![uint])
    }
    pub fn float_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![float])
    }
    pub fn angle_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![angle])
    }
    pub fn bool_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![bool])
    }
    pub fn duration_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![duration])
    }
    pub fn stretch_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![stretch])
    }
    pub fn complex_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![complex])
    }
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn scalar_type(&self) -> Option<ScalarType> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayType {
    pub(crate) syntax: SyntaxNode,
}
impl ArrayType {
    pub fn array_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![array])
    }
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn scalar_type(&self) -> Option<ScalarType> {
        support::child(&self.syntax)
    }
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
    pub fn expression_list(&self) -> Option<ExpressionList> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InvModifier {
    pub(crate) syntax: SyntaxNode,
}
impl InvModifier {
    pub fn inv_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![inv])
    }
    pub fn at_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![@])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PowModifier {
    pub(crate) syntax: SyntaxNode,
}
impl PowModifier {
    pub fn pow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pow])
    }
    pub fn paren_expr(&self) -> Option<ParenExpr> {
        support::child(&self.syntax)
    }
    pub fn at_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![@])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CtrlModifier {
    pub(crate) syntax: SyntaxNode,
}
impl CtrlModifier {
    pub fn ctrl_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ctrl])
    }
    pub fn paren_expr(&self) -> Option<ParenExpr> {
        support::child(&self.syntax)
    }
    pub fn at_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![@])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NegCtrlModifier {
    pub(crate) syntax: SyntaxNode,
}
impl NegCtrlModifier {
    pub fn negctrl_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![negctrl])
    }
    pub fn paren_expr(&self) -> Option<ParenExpr> {
        support::child(&self.syntax)
    }
    pub fn at_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![@])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Designator {
    pub(crate) syntax: SyntaxNode,
}
impl Designator {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QubitType {
    pub(crate) syntax: SyntaxNode,
}
impl QubitType {
    pub fn qubit_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![qubit])
    }
    pub fn designator(&self) -> Option<Designator> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnSignature {
    pub(crate) syntax: SyntaxNode,
}
impl ReturnSignature {
    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![->])
    }
    pub fn scalar_type(&self) -> Option<ScalarType> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AliasDeclarationStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for AliasDeclarationStatement {}
impl AliasDeclarationStatement {
    pub fn let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![let])
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn alias_expression(&self) -> Option<AliasExpression> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AliasExpression {
    pub(crate) syntax: SyntaxNode,
}
impl AliasExpression {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SetExpression {
    pub(crate) syntax: SyntaxNode,
}
impl SetExpression {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn expression_list(&self) -> Option<ExpressionList> {
        support::child(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstDeclarationStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for ConstDeclarationStatement {}
impl ConstDeclarationStatement {
    pub fn const_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![const])
    }
    pub fn scalar_type(&self) -> Option<ScalarType> {
        support::child(&self.syntax)
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IODeclarationStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for IODeclarationStatement {}
impl IODeclarationStatement {
    pub fn input_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![input])
    }
    pub fn output_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![output])
    }
    pub fn scalar_type(&self) -> Option<ScalarType> {
        support::child(&self.syntax)
    }
    pub fn array_type(&self) -> Option<ArrayType> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OldStyleDeclarationStatement {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for OldStyleDeclarationStatement {}
impl OldStyleDeclarationStatement {
    pub fn creg_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![creg])
    }
    pub fn qreg_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![qreg])
    }
    pub fn designator(&self) -> Option<Designator> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Item {
    Def(Def),
    Gate(Gate),
    DefCal(DefCal),
    Cal(Cal),
    DefCalGrammar(DefCalGrammar),
    TypeDeclarationStmt(TypeDeclarationStmt),
    ClassicalDeclarationStatement(ClassicalDeclarationStatement),
    QuantumDeclarationStatement(QuantumDeclarationStatement),
    GPhaseCallStmt(GPhaseCallStmt),
    LetStmt(LetStmt),
    AssignmentStmt(AssignmentStmt),
    Include(Include),
    ForStmt(ForStmt),
    IfStmt(IfStmt),
    WhileStmt(WhileStmt),
    Reset(Reset),
    Measure(Measure),
    Barrier(Barrier),
    VersionString(VersionString),
    BreakStmt(BreakStmt),
    ContinueStmt(ContinueStmt),
    EndStmt(EndStmt),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    ArrayExpr(ArrayExpr),
    ArrayLiteral(ArrayLiteral),
    BinExpr(BinExpr),
    BlockExpr(BlockExpr),
    BoxExpr(BoxExpr),
    CallExpr(CallExpr),
    CastExpression(CastExpression),
    GateCallExpr(GateCallExpr),
    HardwareQubit(HardwareQubit),
    Identifier(Identifier),
    IndexExpr(IndexExpr),
    IndexedIdentifier(IndexedIdentifier),
    Literal(Literal),
    MeasureExpression(MeasureExpression),
    ModifiedGateCallExpr(ModifiedGateCallExpr),
    ParenExpr(ParenExpr),
    RangeExpr(RangeExpr),
    ReturnExpr(ReturnExpr),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GateOperand {
    Identifier(Identifier),
    IndexedIdentifier(IndexedIdentifier),
    HardwareQubit(HardwareQubit),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    ExprStmt(ExprStmt),
    Item(Item),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Modifier {
    InvModifier(InvModifier),
    PowModifier(PowModifier),
    CtrlModifier(CtrlModifier),
    NegCtrlModifier(NegCtrlModifier),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum IndexKind {
    SetExpression(SetExpression),
    ExpressionList(ExpressionList),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasArgList {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasArgList for AnyHasArgList {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasModuleItem {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasModuleItem for AnyHasModuleItem {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasName {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for AnyHasName {}
impl AstNode for Name {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAME
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SourceFile {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SOURCE_FILE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Def {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEF
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Gate {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == GATE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DefCal {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEF_CAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Cal {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DefCalGrammar {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEF_CAL_GRAMMAR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TypeDeclarationStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_DECLARATION_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ClassicalDeclarationStatement {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CLASSICAL_DECLARATION_STATEMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for QuantumDeclarationStatement {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == QUANTUM_DECLARATION_STATEMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for GPhaseCallStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == G_PHASE_CALL_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssignmentStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSIGNMENT_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Include {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INCLUDE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ForStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FOR_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IfStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IF_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WhileStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WHILE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Reset {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RESET
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Measure {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MEASURE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Barrier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BARRIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VersionString {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VERSION_STRING
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BreakStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BREAK_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ContinueStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONTINUE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for EndStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == END_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Version {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VERSION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for QubitList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == QUBIT_LIST
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BlockExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BLOCK_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FilePath {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FILE_PATH
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TypeSpec {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_SPEC
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ParamList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PARAM_LIST
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for RetType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RET_TYPE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Param {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PARAM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExternItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXTERN_ITEM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExprStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPR_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ArrayExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARRAY_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ArrayLiteral {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARRAY_LITERAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BinExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BIN_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BoxExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BOX_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CallExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CALL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CastExpression {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CAST_EXPRESSION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for GateCallExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == GATE_CALL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for HardwareQubit {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == HARDWARE_QUBIT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Identifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENTIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IndexExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INDEX_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IndexedIdentifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INDEXED_IDENTIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Literal {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LITERAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MeasureExpression {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MEASURE_EXPRESSION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ModifiedGateCallExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MODIFIED_GATE_CALL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ParenExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PAREN_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for RangeExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RANGE_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ReturnExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RETURN_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ConcatenationExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONCATENATION_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IndexOperator {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INDEX_OPERATOR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ArgList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARG_LIST
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExpressionList {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPRESSION_LIST
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ScalarType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SCALAR_TYPE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ArrayType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARRAY_TYPE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InvModifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INV_MODIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PowModifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == POW_MODIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CtrlModifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CTRL_MODIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NegCtrlModifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NEG_CTRL_MODIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Designator {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DESIGNATOR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for QubitType {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == QUBIT_TYPE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ReturnSignature {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RETURN_SIGNATURE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AliasDeclarationStatement {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ALIAS_DECLARATION_STATEMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AliasExpression {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ALIAS_EXPRESSION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SetExpression {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SET_EXPRESSION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ConstDeclarationStatement {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONST_DECLARATION_STATEMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IODeclarationStatement {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == I_O_DECLARATION_STATEMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for OldStyleDeclarationStatement {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OLD_STYLE_DECLARATION_STATEMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl From<Def> for Item {
    fn from(node: Def) -> Item {
        Item::Def(node)
    }
}
impl From<Gate> for Item {
    fn from(node: Gate) -> Item {
        Item::Gate(node)
    }
}
impl From<DefCal> for Item {
    fn from(node: DefCal) -> Item {
        Item::DefCal(node)
    }
}
impl From<Cal> for Item {
    fn from(node: Cal) -> Item {
        Item::Cal(node)
    }
}
impl From<DefCalGrammar> for Item {
    fn from(node: DefCalGrammar) -> Item {
        Item::DefCalGrammar(node)
    }
}
impl From<TypeDeclarationStmt> for Item {
    fn from(node: TypeDeclarationStmt) -> Item {
        Item::TypeDeclarationStmt(node)
    }
}
impl From<ClassicalDeclarationStatement> for Item {
    fn from(node: ClassicalDeclarationStatement) -> Item {
        Item::ClassicalDeclarationStatement(node)
    }
}
impl From<QuantumDeclarationStatement> for Item {
    fn from(node: QuantumDeclarationStatement) -> Item {
        Item::QuantumDeclarationStatement(node)
    }
}
impl From<GPhaseCallStmt> for Item {
    fn from(node: GPhaseCallStmt) -> Item {
        Item::GPhaseCallStmt(node)
    }
}
impl From<LetStmt> for Item {
    fn from(node: LetStmt) -> Item {
        Item::LetStmt(node)
    }
}
impl From<AssignmentStmt> for Item {
    fn from(node: AssignmentStmt) -> Item {
        Item::AssignmentStmt(node)
    }
}
impl From<Include> for Item {
    fn from(node: Include) -> Item {
        Item::Include(node)
    }
}
impl From<ForStmt> for Item {
    fn from(node: ForStmt) -> Item {
        Item::ForStmt(node)
    }
}
impl From<IfStmt> for Item {
    fn from(node: IfStmt) -> Item {
        Item::IfStmt(node)
    }
}
impl From<WhileStmt> for Item {
    fn from(node: WhileStmt) -> Item {
        Item::WhileStmt(node)
    }
}
impl From<Reset> for Item {
    fn from(node: Reset) -> Item {
        Item::Reset(node)
    }
}
impl From<Measure> for Item {
    fn from(node: Measure) -> Item {
        Item::Measure(node)
    }
}
impl From<Barrier> for Item {
    fn from(node: Barrier) -> Item {
        Item::Barrier(node)
    }
}
impl From<VersionString> for Item {
    fn from(node: VersionString) -> Item {
        Item::VersionString(node)
    }
}
impl From<BreakStmt> for Item {
    fn from(node: BreakStmt) -> Item {
        Item::BreakStmt(node)
    }
}
impl From<ContinueStmt> for Item {
    fn from(node: ContinueStmt) -> Item {
        Item::ContinueStmt(node)
    }
}
impl From<EndStmt> for Item {
    fn from(node: EndStmt) -> Item {
        Item::EndStmt(node)
    }
}
impl AstNode for Item {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            DEF | GATE
                | DEF_CAL
                | CAL
                | DEF_CAL_GRAMMAR
                | TYPE_DECLARATION_STMT
                | CLASSICAL_DECLARATION_STATEMENT
                | QUANTUM_DECLARATION_STATEMENT
                | G_PHASE_CALL_STMT
                | LET_STMT
                | ASSIGNMENT_STMT
                | INCLUDE
                | FOR_STMT
                | IF_STMT
                | WHILE_STMT
                | RESET
                | MEASURE
                | BARRIER
                | VERSION_STRING
                | BREAK_STMT
                | CONTINUE_STMT
                | END_STMT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            DEF => Item::Def(Def { syntax }),
            GATE => Item::Gate(Gate { syntax }),
            DEF_CAL => Item::DefCal(DefCal { syntax }),
            CAL => Item::Cal(Cal { syntax }),
            DEF_CAL_GRAMMAR => Item::DefCalGrammar(DefCalGrammar { syntax }),
            TYPE_DECLARATION_STMT => Item::TypeDeclarationStmt(TypeDeclarationStmt { syntax }),
            CLASSICAL_DECLARATION_STATEMENT => {
                Item::ClassicalDeclarationStatement(ClassicalDeclarationStatement { syntax })
            }
            QUANTUM_DECLARATION_STATEMENT => {
                Item::QuantumDeclarationStatement(QuantumDeclarationStatement { syntax })
            }
            G_PHASE_CALL_STMT => Item::GPhaseCallStmt(GPhaseCallStmt { syntax }),
            LET_STMT => Item::LetStmt(LetStmt { syntax }),
            ASSIGNMENT_STMT => Item::AssignmentStmt(AssignmentStmt { syntax }),
            INCLUDE => Item::Include(Include { syntax }),
            FOR_STMT => Item::ForStmt(ForStmt { syntax }),
            IF_STMT => Item::IfStmt(IfStmt { syntax }),
            WHILE_STMT => Item::WhileStmt(WhileStmt { syntax }),
            RESET => Item::Reset(Reset { syntax }),
            MEASURE => Item::Measure(Measure { syntax }),
            BARRIER => Item::Barrier(Barrier { syntax }),
            VERSION_STRING => Item::VersionString(VersionString { syntax }),
            BREAK_STMT => Item::BreakStmt(BreakStmt { syntax }),
            CONTINUE_STMT => Item::ContinueStmt(ContinueStmt { syntax }),
            END_STMT => Item::EndStmt(EndStmt { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Item::Def(it) => &it.syntax,
            Item::Gate(it) => &it.syntax,
            Item::DefCal(it) => &it.syntax,
            Item::Cal(it) => &it.syntax,
            Item::DefCalGrammar(it) => &it.syntax,
            Item::TypeDeclarationStmt(it) => &it.syntax,
            Item::ClassicalDeclarationStatement(it) => &it.syntax,
            Item::QuantumDeclarationStatement(it) => &it.syntax,
            Item::GPhaseCallStmt(it) => &it.syntax,
            Item::LetStmt(it) => &it.syntax,
            Item::AssignmentStmt(it) => &it.syntax,
            Item::Include(it) => &it.syntax,
            Item::ForStmt(it) => &it.syntax,
            Item::IfStmt(it) => &it.syntax,
            Item::WhileStmt(it) => &it.syntax,
            Item::Reset(it) => &it.syntax,
            Item::Measure(it) => &it.syntax,
            Item::Barrier(it) => &it.syntax,
            Item::VersionString(it) => &it.syntax,
            Item::BreakStmt(it) => &it.syntax,
            Item::ContinueStmt(it) => &it.syntax,
            Item::EndStmt(it) => &it.syntax,
        }
    }
}
impl From<ArrayExpr> for Expr {
    fn from(node: ArrayExpr) -> Expr {
        Expr::ArrayExpr(node)
    }
}
impl From<ArrayLiteral> for Expr {
    fn from(node: ArrayLiteral) -> Expr {
        Expr::ArrayLiteral(node)
    }
}
impl From<BinExpr> for Expr {
    fn from(node: BinExpr) -> Expr {
        Expr::BinExpr(node)
    }
}
impl From<BlockExpr> for Expr {
    fn from(node: BlockExpr) -> Expr {
        Expr::BlockExpr(node)
    }
}
impl From<BoxExpr> for Expr {
    fn from(node: BoxExpr) -> Expr {
        Expr::BoxExpr(node)
    }
}
impl From<CallExpr> for Expr {
    fn from(node: CallExpr) -> Expr {
        Expr::CallExpr(node)
    }
}
impl From<CastExpression> for Expr {
    fn from(node: CastExpression) -> Expr {
        Expr::CastExpression(node)
    }
}
impl From<GateCallExpr> for Expr {
    fn from(node: GateCallExpr) -> Expr {
        Expr::GateCallExpr(node)
    }
}
impl From<HardwareQubit> for Expr {
    fn from(node: HardwareQubit) -> Expr {
        Expr::HardwareQubit(node)
    }
}
impl From<Identifier> for Expr {
    fn from(node: Identifier) -> Expr {
        Expr::Identifier(node)
    }
}
impl From<IndexExpr> for Expr {
    fn from(node: IndexExpr) -> Expr {
        Expr::IndexExpr(node)
    }
}
impl From<IndexedIdentifier> for Expr {
    fn from(node: IndexedIdentifier) -> Expr {
        Expr::IndexedIdentifier(node)
    }
}
impl From<Literal> for Expr {
    fn from(node: Literal) -> Expr {
        Expr::Literal(node)
    }
}
impl From<MeasureExpression> for Expr {
    fn from(node: MeasureExpression) -> Expr {
        Expr::MeasureExpression(node)
    }
}
impl From<ModifiedGateCallExpr> for Expr {
    fn from(node: ModifiedGateCallExpr) -> Expr {
        Expr::ModifiedGateCallExpr(node)
    }
}
impl From<ParenExpr> for Expr {
    fn from(node: ParenExpr) -> Expr {
        Expr::ParenExpr(node)
    }
}
impl From<RangeExpr> for Expr {
    fn from(node: RangeExpr) -> Expr {
        Expr::RangeExpr(node)
    }
}
impl From<ReturnExpr> for Expr {
    fn from(node: ReturnExpr) -> Expr {
        Expr::ReturnExpr(node)
    }
}
impl AstNode for Expr {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ARRAY_EXPR
                | ARRAY_LITERAL
                | BIN_EXPR
                | BLOCK_EXPR
                | BOX_EXPR
                | CALL_EXPR
                | CAST_EXPRESSION
                | GATE_CALL_EXPR
                | HARDWARE_QUBIT
                | IDENTIFIER
                | INDEX_EXPR
                | INDEXED_IDENTIFIER
                | LITERAL
                | MEASURE_EXPRESSION
                | MODIFIED_GATE_CALL_EXPR
                | PAREN_EXPR
                | RANGE_EXPR
                | RETURN_EXPR
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ARRAY_EXPR => Expr::ArrayExpr(ArrayExpr { syntax }),
            ARRAY_LITERAL => Expr::ArrayLiteral(ArrayLiteral { syntax }),
            BIN_EXPR => Expr::BinExpr(BinExpr { syntax }),
            BLOCK_EXPR => Expr::BlockExpr(BlockExpr { syntax }),
            BOX_EXPR => Expr::BoxExpr(BoxExpr { syntax }),
            CALL_EXPR => Expr::CallExpr(CallExpr { syntax }),
            CAST_EXPRESSION => Expr::CastExpression(CastExpression { syntax }),
            GATE_CALL_EXPR => Expr::GateCallExpr(GateCallExpr { syntax }),
            HARDWARE_QUBIT => Expr::HardwareQubit(HardwareQubit { syntax }),
            IDENTIFIER => Expr::Identifier(Identifier { syntax }),
            INDEX_EXPR => Expr::IndexExpr(IndexExpr { syntax }),
            INDEXED_IDENTIFIER => Expr::IndexedIdentifier(IndexedIdentifier { syntax }),
            LITERAL => Expr::Literal(Literal { syntax }),
            MEASURE_EXPRESSION => Expr::MeasureExpression(MeasureExpression { syntax }),
            MODIFIED_GATE_CALL_EXPR => Expr::ModifiedGateCallExpr(ModifiedGateCallExpr { syntax }),
            PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),
            RANGE_EXPR => Expr::RangeExpr(RangeExpr { syntax }),
            RETURN_EXPR => Expr::ReturnExpr(ReturnExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::ArrayExpr(it) => &it.syntax,
            Expr::ArrayLiteral(it) => &it.syntax,
            Expr::BinExpr(it) => &it.syntax,
            Expr::BlockExpr(it) => &it.syntax,
            Expr::BoxExpr(it) => &it.syntax,
            Expr::CallExpr(it) => &it.syntax,
            Expr::CastExpression(it) => &it.syntax,
            Expr::GateCallExpr(it) => &it.syntax,
            Expr::HardwareQubit(it) => &it.syntax,
            Expr::Identifier(it) => &it.syntax,
            Expr::IndexExpr(it) => &it.syntax,
            Expr::IndexedIdentifier(it) => &it.syntax,
            Expr::Literal(it) => &it.syntax,
            Expr::MeasureExpression(it) => &it.syntax,
            Expr::ModifiedGateCallExpr(it) => &it.syntax,
            Expr::ParenExpr(it) => &it.syntax,
            Expr::RangeExpr(it) => &it.syntax,
            Expr::ReturnExpr(it) => &it.syntax,
        }
    }
}
impl From<Identifier> for GateOperand {
    fn from(node: Identifier) -> GateOperand {
        GateOperand::Identifier(node)
    }
}
impl From<IndexedIdentifier> for GateOperand {
    fn from(node: IndexedIdentifier) -> GateOperand {
        GateOperand::IndexedIdentifier(node)
    }
}
impl From<HardwareQubit> for GateOperand {
    fn from(node: HardwareQubit) -> GateOperand {
        GateOperand::HardwareQubit(node)
    }
}
impl AstNode for GateOperand {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, IDENTIFIER | INDEXED_IDENTIFIER | HARDWARE_QUBIT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENTIFIER => GateOperand::Identifier(Identifier { syntax }),
            INDEXED_IDENTIFIER => GateOperand::IndexedIdentifier(IndexedIdentifier { syntax }),
            HARDWARE_QUBIT => GateOperand::HardwareQubit(HardwareQubit { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            GateOperand::Identifier(it) => &it.syntax,
            GateOperand::IndexedIdentifier(it) => &it.syntax,
            GateOperand::HardwareQubit(it) => &it.syntax,
        }
    }
}
impl From<ExprStmt> for Stmt {
    fn from(node: ExprStmt) -> Stmt {
        Stmt::ExprStmt(node)
    }
}
impl From<Item> for Stmt {
    fn from(node: Item) -> Stmt {
        Stmt::Item(node)
    }
}
impl From<InvModifier> for Modifier {
    fn from(node: InvModifier) -> Modifier {
        Modifier::InvModifier(node)
    }
}
impl From<PowModifier> for Modifier {
    fn from(node: PowModifier) -> Modifier {
        Modifier::PowModifier(node)
    }
}
impl From<CtrlModifier> for Modifier {
    fn from(node: CtrlModifier) -> Modifier {
        Modifier::CtrlModifier(node)
    }
}
impl From<NegCtrlModifier> for Modifier {
    fn from(node: NegCtrlModifier) -> Modifier {
        Modifier::NegCtrlModifier(node)
    }
}
impl AstNode for Modifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            INV_MODIFIER | POW_MODIFIER | CTRL_MODIFIER | NEG_CTRL_MODIFIER
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INV_MODIFIER => Modifier::InvModifier(InvModifier { syntax }),
            POW_MODIFIER => Modifier::PowModifier(PowModifier { syntax }),
            CTRL_MODIFIER => Modifier::CtrlModifier(CtrlModifier { syntax }),
            NEG_CTRL_MODIFIER => Modifier::NegCtrlModifier(NegCtrlModifier { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Modifier::InvModifier(it) => &it.syntax,
            Modifier::PowModifier(it) => &it.syntax,
            Modifier::CtrlModifier(it) => &it.syntax,
            Modifier::NegCtrlModifier(it) => &it.syntax,
        }
    }
}
impl From<SetExpression> for IndexKind {
    fn from(node: SetExpression) -> IndexKind {
        IndexKind::SetExpression(node)
    }
}
impl From<ExpressionList> for IndexKind {
    fn from(node: ExpressionList) -> IndexKind {
        IndexKind::ExpressionList(node)
    }
}
impl AstNode for IndexKind {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, SET_EXPRESSION | EXPRESSION_LIST)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            SET_EXPRESSION => IndexKind::SetExpression(SetExpression { syntax }),
            EXPRESSION_LIST => IndexKind::ExpressionList(ExpressionList { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            IndexKind::SetExpression(it) => &it.syntax,
            IndexKind::ExpressionList(it) => &it.syntax,
        }
    }
}
impl AnyHasArgList {
    #[inline]
    pub fn new<T: ast::HasArgList>(node: T) -> AnyHasArgList {
        AnyHasArgList {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasArgList {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, CALL_EXPR | GATE_CALL_EXPR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasArgList { syntax })
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AnyHasModuleItem {
    #[inline]
    pub fn new<T: ast::HasModuleItem>(node: T) -> AnyHasModuleItem {
        AnyHasModuleItem {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasModuleItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, SOURCE_FILE)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasModuleItem { syntax })
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AnyHasName {
    #[inline]
    pub fn new<T: ast::HasName>(node: T) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasName {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            DEF | GATE
                | DEF_CAL
                | TYPE_DECLARATION_STMT
                | CLASSICAL_DECLARATION_STATEMENT
                | QUANTUM_DECLARATION_STATEMENT
                | LET_STMT
                | ASSIGNMENT_STMT
                | TYPE_SPEC
                | PARAM
                | EXTERN_ITEM
                | GATE_CALL_EXPR
                | HARDWARE_QUBIT
                | INDEXED_IDENTIFIER
                | ALIAS_DECLARATION_STATEMENT
                | CONST_DECLARATION_STATEMENT
                | I_O_DECLARATION_STATEMENT
                | OLD_STYLE_DECLARATION_STATEMENT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasName { syntax })
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl std::fmt::Display for Item {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GateOperand {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Modifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IndexKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SourceFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Def {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Gate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefCal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Cal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefCalGrammar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeDeclarationStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClassicalDeclarationStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for QuantumDeclarationStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GPhaseCallStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssignmentStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Include {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IfStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WhileStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Reset {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Measure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Barrier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VersionString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BreakStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ContinueStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EndStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Version {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for QubitList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BlockExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FilePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParamList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Param {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExternItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExprStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArrayExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArrayLiteral {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BoxExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CastExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GateCallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for HardwareQubit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Identifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IndexExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IndexedIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MeasureExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ModifiedGateCallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParenExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RangeExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ReturnExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConcatenationExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IndexOperator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExpressionList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ScalarType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArrayType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InvModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PowModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CtrlModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NegCtrlModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Designator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for QubitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ReturnSignature {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AliasDeclarationStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AliasExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SetExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConstDeclarationStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IODeclarationStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OldStyleDeclarationStatement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
